import type { LearningItem } from "@/interfaces/jsonTypes";

export const learningData: LearningItem[] = [
  {
    "id": "T01",
    "title": "Computer Science & Programming Fundamentals",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "medium",
    "details": "Build the foundational mental models for how programs run: CPU executes instructions, memory is allocated and accessed, the OS schedules work, and concurrency models shape application behavior. This topic is about practical CS\u2014not academic depth\u2014so you can reason about performance, memory usage, scalability bottlenecks, and debugging symptoms in real systems.",
    "projectsCoveredIn": [
      "P1",
      "P5"
    ],
    "references": [
      "CS50 (Harvard) - lectures on memory, pointers, and runtime basics",
      "Nand2Tetris (optional for deeper intuition)",
      "Operating Systems: Three Easy Pieces (OSTEP) - selected chapters",
      "High Performance Browser Networking (for practical systems thinking overlap)"
    ],
    "subTasks": [
      {
        "id": "T01-ST01",
        "title": "How computers execute programs (CPU, memory, OS basics)",
        "details": "Understand the high-level flow: source code \u2192 compiled/interpreted \u2192 instructions executed by CPU; data loaded/stored via memory; OS manages processes, threads, scheduling, and IO. Focus on concepts that explain real web issues: why CPU-bound tasks block Node, why memory pressure slows everything, why context switching matters, why IO feels 'async'.",
        "masteryCriteria": [
          {
            "criteria": "Can explain what a process is vs a thread in simple terms",
            "mastered": true
          },
          {
            "criteria": "Can explain why CPU-bound tasks block Node's event loop",
            "mastered": false
          },
          {
            "criteria": "Can explain how OS scheduling and IO affect latency",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write a Node script that blocks CPU (tight loop) and observe request latency",
            "completed": false
          },
          {
            "task": "Run multiple processes and compare with single process",
            "completed": true
          },
          {
            "task": "Measure with simple timing logs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "cpu-vs-io-demo",
            "url": "",
            "status": "not-started"
          },
          {
            "type": "notes",
            "label": "process-thread-io-notes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "CS50 - Memory & runtime lectures",
          "OSTEP - Processes + CPU scheduling chapters",
          "Node.js docs - event loop basics (as supporting reading)"
        ],
        "estimatedHours": 6,
        "status": "not-started",
        "blog": {
          "title": "How Your Code Actually Runs: CPU, Memory, OS (For Web Developers)",
          "gist": "Explain program execution path, what the OS does, why CPU-bound work kills Node, and how IO differs from CPU work. Include one mini experiment and results.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T01-ST02",
        "title": "Stack vs Heap",
        "details": "Learn what stack frames are (function calls, local variables) vs heap allocations (objects, closures). Understand symptoms: stack overflow (deep recursion) vs heap growth (memory leak). Tie it back to JS/TS: closures and long-lived references grow heap; recursion can overflow stack; large objects can pressure heap and GC.",
        "masteryCriteria": [
          {
            "criteria": "Can explain what stack frames are and how function calls build them",
            "mastered": false
          },
          {
            "criteria": "Can explain what heap allocations are (objects/closures)",
            "mastered": false
          },
          {
            "criteria": "Can explain stack overflow vs heap memory leak symptoms",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create a recursion example to trigger stack overflow",
            "completed": false
          },
          {
            "task": "Create a loop that allocates objects and observe memory growth",
            "completed": false
          },
          {
            "task": "Write a short note: why closures keep memory alive",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "stack-heap-demos",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Memory management",
          "V8 docs/blogs on heap and GC (high-level)"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Stack vs Heap: The Mental Model That Fixes Debugging Confusion",
          "gist": "Explain stack frames, heap allocations, and how web apps leak memory. Include 2 small code examples (stack overflow + heap growth).",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T01-ST03",
        "title": "Garbage collection (high-level)",
        "details": "Understand how GC decides what can be freed: reachability. Learn why GC pauses can cause jank, why allocating many objects increases GC work, and why memory leaks still occur (objects remain reachable unintentionally). You don't need GC algorithms in depth\u2014focus on practical impact and patterns.",
        "masteryCriteria": [
          {
            "criteria": "Can explain \u2018reachable objects' and why that prevents freeing",
            "mastered": false
          },
          {
            "criteria": "Can describe why frequent allocations cause more GC work",
            "mastered": false
          },
          {
            "criteria": "Can connect GC pressure to UI jank / latency spikes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create two versions of a loop: alloc-heavy vs reuse objects; compare performance",
            "completed": false
          },
          {
            "task": "Record a brief note on reachability and common leak patterns",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "gc-reachability-notes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Memory management",
          "Google/V8 blog posts about GC (overview level)"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Garbage Collection Isn't Magic: Reachability, Pauses, and Leaks",
          "gist": "Explain reachability, why GC pauses happen, and practical ways to reduce allocation pressure in JS apps.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T01-ST04",
        "title": "Big-O basics (when it matters, when it doesn't)",
        "details": "Learn practical complexity: O(n), O(log n), O(n log n). Understand when Big-O matters (large input size, hot paths) and when it doesn't (tiny lists, IO dominates). Tie it to real web: rendering 10k rows, searching/filtering, backend loops, N+1 queries (later topic).",
        "masteryCriteria": [
          {
            "criteria": "Can identify complexity of common operations (map/filter/sort/search)",
            "mastered": false
          },
          {
            "criteria": "Can explain when IO dominates vs when CPU dominates",
            "mastered": false
          },
          {
            "criteria": "Can spot an accidental O(n^2) in UI or backend",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write a quick benchmark: naive nested loop vs optimized map lookup",
            "completed": false
          },
          {
            "task": "Document one real-world place Big-O impacts web apps (lists, search, indexing)",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "big-o-web-benchmarks",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Big-O Cheat Sheet (reference only)",
          "Any standard algorithms text/notes (light)"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Big-O for Web Developers: When It Matters and When It's a Distraction",
          "gist": "Show 2 examples: one where Big-O matters (10k items), one where it doesn't (IO-bound). Provide rule-of-thumb decisions.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T01-ST05",
        "title": "Data structures you actually use (arrays, maps, sets, trees, graphs)",
        "details": "Learn practical usage: arrays for ordered collections; maps for key lookup; sets for uniqueness; trees for hierarchical UI/state; graphs for dependencies (like your architecture visualization work). Focus on choosing the right structure and avoiding slow operations.",
        "masteryCriteria": [
          {
            "criteria": "Can choose Map/Set over Array when lookup/uniqueness is needed",
            "mastered": false
          },
          {
            "criteria": "Can model UI hierarchy as a tree",
            "mastered": false
          },
          {
            "criteria": "Can explain basic graph concepts (nodes/edges) used in real apps",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Refactor a list feature to use Map for O(1) lookup",
            "completed": false
          },
          {
            "task": "Model a UI navigation or component tree",
            "completed": false
          },
          {
            "task": "Create a simple graph representation and traverse it",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "data-structures-in-web",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Map/Set",
          "Simple DS guides (practical, not academic)"
        ],
        "estimatedHours": 5,
        "status": "not-started",
        "blog": {
          "title": "The Only Data Structures You Need for 90% of Web Apps",
          "gist": "Explain real decisions: when Array fails, why Map/Set saves time, where trees/graphs appear in UI and architecture.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T01-ST06",
        "title": "Immutability vs mutation (real-world tradeoffs)",
        "details": "Understand why immutability helps correctness (predictable state updates, time travel debugging) but can cost performance (copying large objects). Learn where mutation is safe and beneficial (local variables, isolated objects, performance-critical sections) and where it becomes dangerous (shared state).",
        "masteryCriteria": [
          {
            "criteria": "Can explain why immutable updates help React/state debugging",
            "mastered": false
          },
          {
            "criteria": "Can identify performance cost of deep copies",
            "mastered": false
          },
          {
            "criteria": "Can decide when mutation is safe (local scope) vs unsafe (shared state)",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement immutable updates for nested state (correctly)",
            "completed": false
          },
          {
            "task": "Benchmark naive deep copy vs targeted update",
            "completed": false
          },
          {
            "task": "Write a short rulebook for your own projects",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "immutability-rulebook",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Redux Style Guide",
          "React docs on state updates"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Immutability Is a Tool, Not a Religion",
          "gist": "Show where immutability saves you (state), and where mutation is fine (local). Include a benchmark example.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T01-ST07",
        "title": "Concurrency vs parallelism",
        "details": "Concurrency is structuring work to make progress on multiple tasks; parallelism is executing multiple tasks at the same time. This matters for web because many tasks are IO-bound (concurrency helps) while CPU-bound workloads need parallelism (workers, multiple processes, separate services).",
        "masteryCriteria": [
          {
            "criteria": "Can explain concurrency vs parallelism with IO vs CPU examples",
            "mastered": false
          },
          {
            "criteria": "Can identify when adding threads/processes helps",
            "mastered": false
          },
          {
            "criteria": "Can reason about latency improvements via concurrency",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write a small program that runs IO concurrently and compare time",
            "completed": false
          },
          {
            "task": "Write a CPU-heavy example and show concurrency doesn't help without parallelism",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "concurrency-parallelism-demos",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OSTEP - concurrency chapters (selected)",
          "Node.js docs on worker threads (overview)"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Concurrency vs Parallelism: The Web Developer's Version",
          "gist": "Use IO (HTTP requests) vs CPU (hashing loop) examples to show the difference and why it affects app design.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T01-ST08",
        "title": "Threads vs event loops",
        "details": "Compare threaded models (one request per thread) vs event-loop models (single-threaded main loop + async IO). Understand where Node shines (IO concurrency) and where it struggles (CPU-heavy tasks) and how to mitigate (worker threads, child processes, queues).",
        "masteryCriteria": [
          {
            "criteria": "Can explain event loop model and why it scales for IO",
            "mastered": false
          },
          {
            "criteria": "Can explain why CPU-heavy work blocks Node",
            "mastered": false
          },
          {
            "criteria": "Can list mitigation options (workers/processes/queues)",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build a simple HTTP server and simulate CPU vs IO load",
            "completed": false
          },
          {
            "task": "Add a worker thread/process to offload CPU work",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "threads-vs-eventloop-node",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Node.js event loop docs",
          "Node.js worker threads docs"
        ],
        "estimatedHours": 5,
        "status": "not-started",
        "blog": {
          "title": "Threads vs Event Loops: Choosing the Right Mental Model",
          "gist": "Explain how Node handles concurrency, why it blocks, and how real systems offload CPU-heavy work.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T02",
    "title": "JavaScript Deep Dive",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "medium",
    "details": "This topic builds a precise mental model of how JavaScript actually works at runtime. The goal is not memorizing syntax, but understanding execution order, async behavior, memory, object models, and performance characteristics so you can debug confidently, reason about bugs, and avoid subtle production issues.",
    "projectsCoveredIn": [
      "P1",
      "MP1"
    ],
    "references": [
      "You Don't Know JS Yet (Kyle Simpson)",
      "MDN JavaScript Guide",
      "V8 Blog (high-level performance concepts)"
    ],
    "subTasks": [
      {
        "id": "T02-ST01",
        "title": "JS execution model",
        "details": "Understand how JavaScript code is executed through execution contexts: global context, function contexts, and how they are created and destroyed. Focus on how variable environments, scope, and the call stack work together during execution.",
        "masteryCriteria": [
          {
            "criteria": "Can explain what an execution context is",
            "mastered": false
          },
          {
            "criteria": "Can explain the difference between global and function execution contexts",
            "mastered": false
          },
          {
            "criteria": "Can trace execution order of a simple script mentally",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write a script with nested functions and console.log execution order",
            "completed": false
          },
          {
            "task": "Manually trace execution contexts step by step",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "js-execution-context-notes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "You Don't Know JS - Scope & Closures",
          "MDN - Execution Context"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "The JavaScript Execution Model: What Actually Happens When Code Runs",
          "gist": "Explain execution contexts, variable environments, and how JS executes code step by step with a traced example.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T02-ST02",
        "title": "Call stack",
        "details": "Learn how function calls are stacked and unwound using the call stack. Understand stack frames, synchronous execution, and why deep recursion or infinite loops cause stack overflows.",
        "masteryCriteria": [
          {
            "criteria": "Can explain what a stack frame contains",
            "mastered": false
          },
          {
            "criteria": "Can explain stack overflow errors",
            "mastered": false
          },
          {
            "criteria": "Can debug errors by reading stack traces",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create a recursive function that causes a stack overflow",
            "completed": false
          },
          {
            "task": "Inspect stack traces in browser DevTools",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "call-stack-demos",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Call Stack",
          "Chrome DevTools Debugger Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Understanding the JavaScript Call Stack (And Stack Overflows)",
          "gist": "Explain stack frames, recursion, and how to read stack traces during debugging.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T02-ST03",
        "title": "Event loop",
        "details": "Understand how JavaScript handles asynchronous operations using the event loop. Focus on how the call stack, task queues, and browser/Node APIs work together to enable non-blocking behavior.",
        "masteryCriteria": [
          {
            "criteria": "Can explain why async code doesn't block the main thread",
            "mastered": false
          },
          {
            "criteria": "Can predict execution order of mixed sync/async code",
            "mastered": false
          },
          {
            "criteria": "Can explain how browser APIs integrate with JS",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write mixed sync/async examples and predict output",
            "completed": false
          },
          {
            "task": "Visualize execution order with logs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "event-loop-experiments",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Event Loop",
          "Philip Roberts - What the Hell Is the Event Loop?"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "The JavaScript Event Loop Finally Makes Sense",
          "gist": "Explain how the event loop enables async behavior using simple examples and diagrams.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T02-ST04",
        "title": "Tasks vs microtasks",
        "details": "Learn the difference between macrotasks (tasks) and microtasks, their priority, and why promises behave differently from timers. This is critical for understanding subtle async bugs.",
        "masteryCriteria": [
          {
            "criteria": "Can explain why Promise callbacks run before setTimeout",
            "mastered": false
          },
          {
            "criteria": "Can identify bugs caused by incorrect async assumptions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create examples mixing setTimeout, Promise, async/await",
            "completed": false
          },
          {
            "task": "Predict and verify execution order",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "tasks-vs-microtasks",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Jake Archibald - Tasks, Microtasks, Queues and Schedules",
          "MDN - Microtasks"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Tasks vs Microtasks: The Async Detail That Breaks Apps",
          "gist": "Explain microtask priority with real-world bug scenarios.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T02-ST05",
        "title": "Promises internals",
        "details": "Understand how promises work internally: states (pending, fulfilled, rejected), chaining, error propagation, and how promise resolution queues microtasks.",
        "masteryCriteria": [
          {
            "criteria": "Can explain promise states and transitions",
            "mastered": false
          },
          {
            "criteria": "Can explain how errors propagate in promise chains",
            "mastered": false
          },
          {
            "criteria": "Can refactor callback code into promises safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Reimplement a simple promise-like abstraction",
            "completed": false
          },
          {
            "task": "Write chained promises and test error handling",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "promise-internals",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "You Don't Know JS - Async & Performance",
          "MDN - Promises"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Promises Under the Hood: States, Chains, and Errors",
          "gist": "Explain how promises resolve, chain, and propagate errors with diagrams.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T02-ST06",
        "title": "async/await desugaring",
        "details": "Learn how async/await is syntactic sugar over promises. Understand how awaits pause execution without blocking the call stack and how errors are handled.",
        "masteryCriteria": [
          {
            "criteria": "Can rewrite async/await code using promises",
            "mastered": false
          },
          {
            "criteria": "Can explain how try/catch works with async functions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Rewrite async functions into explicit promise chains",
            "completed": false
          },
          {
            "task": "Introduce errors and observe propagation",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "async-await-desugaring",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - async/await",
          "You Don't Know JS - Async & Performance"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "async/await Is Just Promises in Disguise",
          "gist": "Show how async/await compiles mentally to promise chains.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T02-ST07",
        "title": "Closures (real-world pitfalls)",
        "details": "Understand closures as functions retaining access to their lexical scope. Focus on real-world pitfalls: memory leaks, stale values, unexpected shared state.",
        "masteryCriteria": [
          {
            "criteria": "Can explain closures in simple terms",
            "mastered": false
          },
          {
            "criteria": "Can identify closure-related memory leaks",
            "mastered": false
          },
          {
            "criteria": "Can debug stale closure bugs in React",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create a closure-based counter and modify behavior",
            "completed": false
          },
          {
            "task": "Inspect memory usage of closures",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "closure-pitfalls",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "You Don't Know JS - Scope & Closures",
          "MDN - Closures"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Closures: Powerful, Dangerous, and Often Misunderstood",
          "gist": "Explain closures with practical bugs and fixes.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T02-ST08",
        "title": "Scope chains",
        "details": "Understand lexical scoping and how JavaScript resolves variables through the scope chain.",
        "masteryCriteria": [
          {
            "criteria": "Can explain lexical scoping",
            "mastered": false
          },
          {
            "criteria": "Can predict variable resolution in nested scopes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write nested scope examples and predict outputs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "scope-chain-notes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Scope",
          "You Don't Know JS - Scope & Closures"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Scope Chains Demystified",
          "gist": "Explain lexical scoping and variable resolution.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T02-ST09",
        "title": "Hoisting",
        "details": "Understand how declarations are hoisted, and the differences between var, let, const, and function declarations.",
        "masteryCriteria": [
          {
            "criteria": "Can explain hoisting behavior accurately",
            "mastered": false
          },
          {
            "criteria": "Can avoid hoisting-related bugs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Predict outputs of hoisting examples",
            "completed": false
          },
          {
            "task": "Refactor code to avoid hoisting pitfalls",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "hoisting-examples",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Hoisting",
          "You Don't Know JS - Scope & Closures"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Hoisting Without the Myths",
          "gist": "Explain what hoisting really means and what it doesn't.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T02-ST10",
        "title": "Prototypes",
        "details": "Understand JavaScript's prototype-based inheritance model and how objects delegate property access.",
        "masteryCriteria": [
          {
            "criteria": "Can explain prototype chains",
            "mastered": false
          },
          {
            "criteria": "Can debug prototype-related bugs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Manually create objects with Object.create",
            "completed": false
          },
          {
            "task": "Inspect prototype chains in DevTools",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "prototype-chain-demos",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Prototypes",
          "You Don't Know JS - Objects & Classes"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "JavaScript Prototypes Explained Clearly",
          "gist": "Explain prototype delegation with diagrams and examples.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T02-ST11",
        "title": "`this` binding (all cases)",
        "details": "Understand how `this` is bound in different invocation contexts: default, implicit, explicit, new, and arrow functions.",
        "masteryCriteria": [
          {
            "criteria": "Can predict `this` in any context",
            "mastered": false
          },
          {
            "criteria": "Can fix `this`-related bugs confidently",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write examples for each binding rule",
            "completed": false
          },
          {
            "task": "Debug broken `this` usage",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "this-binding-examples",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "You Don't Know JS - this & Object Prototypes",
          "MDN - this"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "The Complete Guide to `this` in JavaScript",
          "gist": "Explain all binding rules with practical examples.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T02-ST12",
        "title": "Memory leaks in JS",
        "details": "Identify common JavaScript memory leak patterns: global references, forgotten timers, event listeners, closures, and detached DOM nodes.",
        "masteryCriteria": [
          {
            "criteria": "Can identify memory leaks using DevTools",
            "mastered": false
          },
          {
            "criteria": "Can fix common leak patterns",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create and fix a leaky app",
            "completed": false
          },
          {
            "task": "Take heap snapshots and compare",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "js-memory-leaks",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Chrome DevTools Memory Guide",
          "MDN - Memory Management"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Common JavaScript Memory Leaks and How to Fix Them",
          "gist": "Walk through leak patterns and DevTools techniques.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T02-ST13",
        "title": "Performance traps (object shapes, hidden classes)",
        "details": "Understand how JS engines optimize objects and how changing object shapes or using dynamic patterns can deoptimize code.",
        "masteryCriteria": [
          {
            "criteria": "Can explain hidden classes at a high level",
            "mastered": false
          },
          {
            "criteria": "Can identify performance traps in hot code paths",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Benchmark stable vs unstable object shapes",
            "completed": false
          },
          {
            "task": "Observe performance differences",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "js-performance-traps",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "V8 Blog - Hidden Classes",
          "Chrome DevTools Performance Guide"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "JavaScript Performance Traps You Didn't Know Existed",
          "gist": "Explain hidden classes and de-optimizations in simple terms.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T03",
    "title": "TypeScript - Professional Usage",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "medium",
    "details": "This topic is about using TypeScript as a system design and correctness tool, not just for catching basic type errors. Mastery means you can model domains accurately, design safe APIs and SDKs, control complexity with types, and know when types help versus when they hurt productivity.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P5"
    ],
    "references": [
      "TypeScript Handbook (Official)",
      "Effective TypeScript - Dan Vanderkam",
      "TypeScript Deep Dive - Basarat"
    ],
    "subTasks": [
      {
        "id": "T03-ST01",
        "title": "Structural typing",
        "details": "Understand TypeScript's structural (duck-typed) system: compatibility based on shape rather than explicit inheritance. Learn how this affects assignability, refactoring safety, and unintended type compatibility.",
        "masteryCriteria": [
          {
            "criteria": "Can explain structural vs nominal typing",
            "mastered": false
          },
          {
            "criteria": "Can predict when two types are assignable",
            "mastered": false
          },
          {
            "criteria": "Can identify bugs caused by accidental structural compatibility",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create two unrelated interfaces with the same shape and test assignability",
            "completed": false
          },
          {
            "task": "Refactor code to intentionally prevent structural compatibility",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "structural-typing-experiments",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "TypeScript Handbook - Type Compatibility",
          "Effective TypeScript - Item on Structural Typing"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Why TypeScript Is Structurally Typed (And Why It Matters)",
          "gist": "Explain structural typing, show surprising assignments, and discuss pros/cons for large codebases.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T03-ST02",
        "title": "Type inference mechanics",
        "details": "Learn how TypeScript infers types from values, function return types, generics, and contextual typing. Focus on when inference is strong enough and when explicit annotations are needed.",
        "masteryCriteria": [
          {
            "criteria": "Can explain contextual typing",
            "mastered": false
          },
          {
            "criteria": "Can predict inferred return types",
            "mastered": false
          },
          {
            "criteria": "Can reduce redundant type annotations safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Remove explicit types and observe inferred types",
            "completed": false
          },
          {
            "task": "Introduce ambiguity and fix inference failures",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "type-inference-notes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "TypeScript Handbook - Type Inference",
          "Effective TypeScript - Inference chapters"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "How TypeScript Infers Types (And When It Fails)",
          "gist": "Explain inference rules with examples and show when explicit types are necessary.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T03-ST03",
        "title": "`unknown` vs `any`",
        "details": "Understand why `unknown` is safer than `any`, how it forces proper type narrowing, and where `any` is acceptable as an escape hatch.",
        "masteryCriteria": [
          {
            "criteria": "Can explain why `unknown` is safer than `any`",
            "mastered": false
          },
          {
            "criteria": "Can correctly narrow `unknown` values",
            "mastered": false
          },
          {
            "criteria": "Can justify rare, intentional use of `any`",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Replace `any` with `unknown` in existing code",
            "completed": false
          },
          {
            "task": "Add proper runtime checks for narrowing",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "unknown-vs-any",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "TypeScript Handbook - unknown",
          "Effective TypeScript - Avoiding `any`"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "`unknown` vs `any`: One Makes Bugs, One Prevents Them",
          "gist": "Show how `unknown` forces safer code with minimal extra effort.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T03-ST04",
        "title": "Generics (constraints, defaults)",
        "details": "Use generics to create reusable, type-safe abstractions. Learn constraints to restrict types and defaults to reduce verbosity for consumers.",
        "masteryCriteria": [
          {
            "criteria": "Can design generic functions and types",
            "mastered": false
          },
          {
            "criteria": "Can use constraints to prevent misuse",
            "mastered": false
          },
          {
            "criteria": "Can apply default generic parameters correctly",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build a generic utility with constraints",
            "completed": false
          },
          {
            "task": "Add defaults and observe improved DX",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "generics-constraints-defaults",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "TypeScript Handbook - Generics",
          "TypeScript Deep Dive - Generics"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Generics That Scale: Constraints and Defaults in Practice",
          "gist": "Explain real-world generic patterns and common mistakes.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T03-ST05",
        "title": "Utility types (built-in + custom)",
        "details": "Understand built-in utility types (Partial, Pick, Omit, Record, Required, Readonly) and how to compose or create custom utilities.",
        "masteryCriteria": [
          {
            "criteria": "Can choose the correct utility type",
            "mastered": false
          },
          {
            "criteria": "Can compose multiple utility types",
            "mastered": false
          },
          {
            "criteria": "Can create custom mapped utility types",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Refactor interfaces using utility types",
            "completed": false
          },
          {
            "task": "Create a custom DeepPartial utility",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "utility-types-playground",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "TypeScript Handbook - Utility Types",
          "Effective TypeScript - Utility Types"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "TypeScript Utility Types You Should Actually Use",
          "gist": "Show practical examples of built-in and custom utility types.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T03-ST06",
        "title": "Discriminated unions",
        "details": "Use discriminated unions to model state machines, API responses, and domain logic safely with exhaustive checking.",
        "masteryCriteria": [
          {
            "criteria": "Can design discriminated union types",
            "mastered": false
          },
          {
            "criteria": "Can use exhaustive switch checking",
            "mastered": false
          },
          {
            "criteria": "Can model complex state safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Model API responses with discriminated unions",
            "completed": false
          },
          {
            "task": "Add exhaustive checks with `never`",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "discriminated-unions",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "TypeScript Handbook - Unions",
          "Effective TypeScript - Discriminated Unions"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Discriminated Unions: TypeScript's Secret Weapon",
          "gist": "Explain how discriminated unions eliminate entire classes of bugs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T03-ST07",
        "title": "Type narrowing",
        "details": "Understand how TypeScript narrows types using control flow analysis, typeof, instanceof, equality checks, and custom guards.",
        "masteryCriteria": [
          {
            "criteria": "Can predict how types narrow in conditionals",
            "mastered": false
          },
          {
            "criteria": "Can write correct narrowing logic",
            "mastered": false
          },
          {
            "criteria": "Can debug incorrect narrowing",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create examples using typeof/instanceof",
            "completed": false
          },
          {
            "task": "Debug a narrowing bug",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "type-narrowing-examples",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "TypeScript Handbook - Narrowing",
          "TypeScript Deep Dive - Control Flow Analysis"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "How TypeScript Narrows Types Behind the Scenes",
          "gist": "Explain control flow analysis with concrete examples.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T03-ST08",
        "title": "Type guards",
        "details": "Learn to write user-defined type guards to safely refine types at runtime, especially when dealing with external data.",
        "masteryCriteria": [
          {
            "criteria": "Can write custom type guard functions",
            "mastered": false
          },
          {
            "criteria": "Can validate unknown data safely",
            "mastered": false
          },
          {
            "criteria": "Can integrate guards with APIs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write guards for API responses",
            "completed": false
          },
          {
            "task": "Replace unsafe casts with guards",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "custom-type-guards",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "TypeScript Handbook - Type Guards",
          "Effective TypeScript - Runtime Safety"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Type Guards: Making Runtime Data Safe in TypeScript",
          "gist": "Explain why type guards are essential for external data.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T03-ST09",
        "title": "Branded types",
        "details": "Use branded (nominal-like) types to prevent logical errors such as mixing IDs, currencies, or units.",
        "masteryCriteria": [
          {
            "criteria": "Can create branded types",
            "mastered": false
          },
          {
            "criteria": "Can prevent accidental type mixing",
            "mastered": false
          },
          {
            "criteria": "Can explain tradeoffs of branding",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create branded ID and currency types",
            "completed": false
          },
          {
            "task": "Refactor code to use brands",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "branded-types",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "TypeScript Deep Dive - Branding",
          "Effective TypeScript - Nominal Typing Patterns"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Branded Types: Preventing Bugs TypeScript Can't Catch",
          "gist": "Explain how branding prevents logical domain errors.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T03-ST10",
        "title": "TS config (`tsconfig`) deeply",
        "details": "Understand compiler options that affect safety, performance, and developer experience. Focus on strictness flags and module settings.",
        "masteryCriteria": [
          {
            "criteria": "Can explain major strict flags",
            "mastered": false
          },
          {
            "criteria": "Can configure TS for large projects",
            "mastered": false
          },
          {
            "criteria": "Can debug tsconfig-related issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Enable strict mode in a project",
            "completed": false
          },
          {
            "task": "Fix resulting type errors",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "tsconfig-deep-dive",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "TypeScript Handbook - Compiler Options",
          "TypeScript Deep Dive - tsconfig"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "tsconfig Explained: The Options That Actually Matter",
          "gist": "Explain key compiler options and when to use them.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T03-ST11",
        "title": "TS for API contracts",
        "details": "Use TypeScript to define and share API contracts between frontend and backend, ensuring end-to-end type safety.",
        "masteryCriteria": [
          {
            "criteria": "Can define shared API types",
            "mastered": false
          },
          {
            "criteria": "Can avoid contract drift",
            "mastered": false
          },
          {
            "criteria": "Can integrate contracts into builds",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Define shared API schemas",
            "completed": false
          },
          {
            "task": "Consume contracts on frontend",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "ts-api-contracts",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "tRPC concepts",
          "OpenAPI + TypeScript workflows"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "TypeScript for API Contracts: End-to-End Safety",
          "gist": "Explain shared types and contract-driven development.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T03-ST12",
        "title": "TS for SDKs",
        "details": "Design and publish TypeScript SDKs with stable APIs, strong typing, good DX, and backward compatibility.",
        "masteryCriteria": [
          {
            "criteria": "Can design a clean SDK API surface",
            "mastered": false
          },
          {
            "criteria": "Can type errors, pagination, and responses",
            "mastered": false
          },
          {
            "criteria": "Can publish types safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build a small typed SDK",
            "completed": false
          },
          {
            "task": "Simulate a breaking change and version it",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "typed-sdk-design",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "TypeScript Handbook - Declaration Files",
          "Stripe SDK (design reference)"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Designing a TypeScript SDK Developers Enjoy Using",
          "gist": "Explain SDK structure, typing strategies, and DX considerations.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T03-ST13",
        "title": "When NOT to over-type",
        "details": "Recognize situations where excessive typing increases complexity without real safety benefits.",
        "masteryCriteria": [
          {
            "criteria": "Can identify over-typed code",
            "mastered": false
          },
          {
            "criteria": "Can simplify types without losing safety",
            "mastered": false
          },
          {
            "criteria": "Can balance speed vs correctness",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Refactor an over-typed example",
            "completed": false
          },
          {
            "task": "Document personal typing guidelines",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "typing-guidelines",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Effective TypeScript - Overuse of Types"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "When TypeScript Hurts More Than It Helps",
          "gist": "Explain the cost of over-typing and how to avoid it.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T04",
    "title": "Browser Internals",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "medium",
    "details": "This topic builds a concrete mental model of how browsers turn HTML, CSS, and JavaScript into pixels on the screen, how they manage storage and caching, and how they enforce security. Mastery here lets you reason about performance issues, rendering bugs, layout jank, storage limits, and security constraints instead of guessing.",
    "projectsCoveredIn": [
      "P1"
    ],
    "references": [
      "MDN Web Docs - Rendering pipeline",
      "Google Developers - Rendering Performance",
      "High Performance Browser Networking - Ilya Grigorik"
    ],
    "subTasks": [
      {
        "id": "T04-ST01",
        "title": "Critical rendering path",
        "details": "Understand how the browser parses HTML into the DOM, CSS into the CSSOM, combines them into the render tree, computes layout, paints pixels, and composites layers. Learn which resources block rendering and why.",
        "masteryCriteria": [
          {
            "criteria": "Can explain each step of the critical rendering path",
            "mastered": false
          },
          {
            "criteria": "Can identify render-blocking resources",
            "mastered": false
          },
          {
            "criteria": "Can explain why CSS blocks rendering but JS blocks parsing",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Load a page and inspect render-blocking resources in DevTools",
            "completed": false
          },
          {
            "task": "Experiment with async/defer scripts and observe differences",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "critical-rendering-path-notes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Critical Rendering Path",
          "web.dev - Render Blocking Resources"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "The Critical Rendering Path: From HTML to Pixels",
          "gist": "Walk through DOM, CSSOM, render tree, layout, paint, and composite with a real page example.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T04-ST02",
        "title": "Layout, reflow, repaint, and composite",
        "details": "Understand the difference between layout (reflow), paint, and composite. Learn which CSS properties trigger which phases and why layout thrashing causes performance issues.",
        "masteryCriteria": [
          {
            "criteria": "Can explain reflow vs repaint vs composite",
            "mastered": false
          },
          {
            "criteria": "Can identify expensive layout-triggering CSS properties",
            "mastered": false
          },
          {
            "criteria": "Can avoid layout thrashing patterns",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Use DevTools to highlight layout and paint events",
            "completed": false
          },
          {
            "task": "Refactor a layout-thrashing example",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "layout-repaint-composite-demos",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google Developers - Rendering Performance",
          "CSSTriggers.com"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Reflow, Repaint, Composite: The Browser Performance Trifecta",
          "gist": "Explain what triggers each phase and how to write CSS/JS that avoids unnecessary work.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T04-ST03",
        "title": "DOM vs Virtual DOM",
        "details": "Understand why manipulating the real DOM directly is expensive, how Virtual DOM works conceptually, and what problems it solves (and does not solve).",
        "masteryCriteria": [
          {
            "criteria": "Can explain why DOM updates are expensive",
            "mastered": false
          },
          {
            "criteria": "Can explain how Virtual DOM diffing works at a high level",
            "mastered": false
          },
          {
            "criteria": "Can identify cases where VDOM does not help",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write vanilla DOM updates and compare with React updates",
            "completed": false
          },
          {
            "task": "Profile DOM mutation costs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "dom-vs-vdom-experiments",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - Reconciliation",
          "MDN - DOM Performance"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "DOM vs Virtual DOM: What Problem Are We Actually Solving?",
          "gist": "Clarify myths around Virtual DOM and explain when it matters.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T04-ST04",
        "title": "Browser storage options",
        "details": "Understand cookies, localStorage, sessionStorage, IndexedDB, Cache Storage, and their tradeoffs in terms of size limits, performance, persistence, and security.",
        "masteryCriteria": [
          {
            "criteria": "Can choose the correct storage mechanism",
            "mastered": false
          },
          {
            "criteria": "Can explain size and security limitations",
            "mastered": false
          },
          {
            "criteria": "Can explain same-origin constraints",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Store and retrieve data using different storage APIs",
            "completed": false
          },
          {
            "task": "Inspect storage in DevTools",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "browser-storage-playground",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Web Storage API",
          "MDN - IndexedDB"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Browser Storage Explained: Cookies vs localStorage vs IndexedDB",
          "gist": "Compare storage options and explain real-world use cases.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T04-ST05",
        "title": "Browser caching layers",
        "details": "Understand memory cache, disk cache, HTTP cache, and how cache headers influence browser behavior.",
        "masteryCriteria": [
          {
            "criteria": "Can explain different browser cache layers",
            "mastered": false
          },
          {
            "criteria": "Can configure HTTP cache headers correctly",
            "mastered": false
          },
          {
            "criteria": "Can debug caching issues in DevTools",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Experiment with Cache-Control headers",
            "completed": false
          },
          {
            "task": "Inspect cache behavior using DevTools network tab",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "browser-caching-experiments",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - HTTP Caching",
          "High Performance Browser Networking"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "How Browser Caching Actually Works",
          "gist": "Explain cache layers and how headers affect resource loading.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T04-ST06",
        "title": "Service workers",
        "details": "Understand how service workers run in the background, intercept network requests, enable offline behavior, and implement advanced caching strategies.",
        "masteryCriteria": [
          {
            "criteria": "Can explain service worker lifecycle",
            "mastered": false
          },
          {
            "criteria": "Can implement offline caching",
            "mastered": false
          },
          {
            "criteria": "Can debug service worker issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Register a service worker",
            "completed": false
          },
          {
            "task": "Implement cache-first and network-first strategies",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "service-worker-offline-demo",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Service Workers",
          "web.dev - Service Workers"
        ],
        "estimatedHours": 5,
        "status": "not-started",
        "blog": {
          "title": "Service Workers Explained: Offline Is a Feature",
          "gist": "Explain lifecycle, caching strategies, and common pitfalls.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T04-ST07",
        "title": "Web workers",
        "details": "Understand how Web Workers enable background threads for CPU-heavy tasks without blocking the main thread, and their communication model.",
        "masteryCriteria": [
          {
            "criteria": "Can explain when to use Web Workers",
            "mastered": false
          },
          {
            "criteria": "Can transfer data between threads safely",
            "mastered": false
          },
          {
            "criteria": "Can identify worker-related overhead",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Offload a CPU-heavy task to a Web Worker",
            "completed": false
          },
          {
            "task": "Measure UI responsiveness before and after",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "web-worker-demo",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Web Workers",
          "Google Developers - Web Workers"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Web Workers: Multithreading for the Browser",
          "gist": "Explain off-main-thread work with real examples.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T04-ST08",
        "title": "Browser security model (XSS, CSRF, CSP)",
        "details": "Understand the browser security sandbox, same-origin policy, and how XSS, CSRF, and CSP relate to browser behavior.",
        "masteryCriteria": [
          {
            "criteria": "Can explain same-origin policy",
            "mastered": false
          },
          {
            "criteria": "Can explain how XSS and CSRF attacks work",
            "mastered": false
          },
          {
            "criteria": "Can configure basic CSP rules",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create a simple XSS example and fix it",
            "completed": false
          },
          {
            "task": "Add CSP headers and observe effects",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "browser-security-basics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Web Security",
          "OWASP - XSS and CSRF"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Browser Security Basics Every Web Developer Must Know",
          "gist": "Explain same-origin policy, XSS, CSRF, and CSP with simple examples.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T05",
    "title": "React - Internals & Advanced Patterns",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic builds a precise mental model of how React actually works: how JSX becomes elements, how reconciliation decides what to update, how rendering is scheduled, and how advanced patterns help build scalable, maintainable UI systems. Mastery means you can reason about re-renders, performance issues, state flow, and architectural tradeoffs instead of relying on trial-and-error.",
    "projectsCoveredIn": [
      "P1"
    ],
    "references": [
      "React Official Docs (Advanced Guides)",
      "Overreacted.io (Dan Abramov)",
      "React RFCs (conceptual reading)"
    ],
    "subTasks": [
      {
        "id": "T05-ST01",
        "title": "JSX compilation",
        "details": "Understand how JSX is transformed into JavaScript function calls (React.createElement or the new JSX transform), what elements actually are, and why JSX is not HTML. This explains why components are just functions and how props/children are represented internally.",
        "masteryCriteria": [
          {
            "criteria": "Can explain what JSX compiles to",
            "mastered": false
          },
          {
            "criteria": "Can explain what a React element is",
            "mastered": false
          },
          {
            "criteria": "Can explain the difference between elements and components",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write JSX and inspect compiled output",
            "completed": false
          },
          {
            "task": "Create React elements manually without JSX",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "jsx-compilation-experiments",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - JSX In Depth",
          "Babel JSX Transform Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "What JSX Really Compiles To (And Why It Matters)",
          "gist": "Explain JSX compilation, React elements, and why JSX is just syntax sugar.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T05-ST02",
        "title": "Reconciliation algorithm",
        "details": "Learn how React compares previous and next element trees to decide what to update. Focus on heuristics (same type, same key), why keys matter, and what React does NOT attempt to do (optimal diffing).",
        "masteryCriteria": [
          {
            "criteria": "Can explain how React decides to reuse or discard components",
            "mastered": false
          },
          {
            "criteria": "Can explain why keys are critical in lists",
            "mastered": false
          },
          {
            "criteria": "Can predict reconciliation behavior in common cases",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build list examples with and without stable keys",
            "completed": false
          },
          {
            "task": "Observe DOM updates using DevTools",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "reconciliation-key-experiments",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - Reconciliation",
          "Overreacted.io - Reconciling Lists"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Inside React Reconciliation: How React Decides What to Update",
          "gist": "Explain reconciliation heuristics, keys, and why React doesn't do deep tree diffs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T05-ST03",
        "title": "Render phase vs commit phase",
        "details": "Understand React's two-phase rendering model. The render phase is pure and interruptible; the commit phase applies changes to the DOM. This distinction explains Strict Mode behavior and why side effects must live in effects.",
        "masteryCriteria": [
          {
            "criteria": "Can explain render vs commit phases",
            "mastered": false
          },
          {
            "criteria": "Can explain why render must be pure",
            "mastered": false
          },
          {
            "criteria": "Can identify side effects placed incorrectly",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Introduce side effects during render and observe issues",
            "completed": false
          },
          {
            "task": "Move side effects to effects correctly",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "render-vs-commit-notes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - Rendering Behavior",
          "Overreacted.io - A Complete Guide to useEffect"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Render vs Commit: The Two Phases of React You Must Understand",
          "gist": "Explain why React separates rendering from DOM mutations and what problems it solves.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T05-ST04",
        "title": "Strict Mode behavior",
        "details": "Understand why React Strict Mode intentionally double-invokes certain lifecycles and effects in development. Learn what problems it detects and why this behavior does not occur in production.",
        "masteryCriteria": [
          {
            "criteria": "Can explain why Strict Mode double-invokes",
            "mastered": false
          },
          {
            "criteria": "Can distinguish dev-only vs prod behavior",
            "mastered": false
          },
          {
            "criteria": "Can fix bugs revealed by Strict Mode",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Enable Strict Mode in an app",
            "completed": false
          },
          {
            "task": "Fix duplicate side-effect issues",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "strict-mode-experiments",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - Strict Mode",
          "Overreacted.io - How to Think About Effects"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Why React Strict Mode Feels Broken (But Isn't)",
          "gist": "Explain double-invocation, what it detects, and how to write Strict-Mode-safe code.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T05-ST05",
        "title": "Controlled vs uncontrolled components",
        "details": "Understand the difference between controlled and uncontrolled inputs, their tradeoffs in forms, performance implications, and how libraries build abstractions on top of these concepts.",
        "masteryCriteria": [
          {
            "criteria": "Can explain controlled vs uncontrolled inputs",
            "mastered": false
          },
          {
            "criteria": "Can choose the right approach for a form",
            "mastered": false
          },
          {
            "criteria": "Can debug form state issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build the same form both ways",
            "completed": false
          },
          {
            "task": "Measure re-render behavior",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "controlled-uncontrolled-forms",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - Forms",
          "Kent C. Dodds - Controlled vs Uncontrolled"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Controlled vs Uncontrolled Components: Choosing the Right Tool",
          "gist": "Explain form control strategies and their performance implications.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T05-ST06",
        "title": "Hooks rules and mental model",
        "details": "Understand why hooks must be called unconditionally and in the same order, how React tracks hook state internally, and what breaks when rules are violated.",
        "masteryCriteria": [
          {
            "criteria": "Can explain why hooks rely on call order",
            "mastered": false
          },
          {
            "criteria": "Can debug invalid hook usage",
            "mastered": false
          },
          {
            "criteria": "Can design custom hooks safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Break the rules of hooks intentionally",
            "completed": false
          },
          {
            "task": "Fix the resulting bugs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "hooks-rules-experiments",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - Rules of Hooks",
          "Overreacted.io - Why Hooks Rely on Call Order"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Why Hooks Have Rules (And What Breaks Without Them)",
          "gist": "Explain hook ordering, internal state tracking, and common mistakes.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T05-ST07",
        "title": "useEffect mental model",
        "details": "Understand effects as synchronization with external systems, not lifecycle methods. Learn dependency arrays, cleanup functions, and how stale closures arise.",
        "masteryCriteria": [
          {
            "criteria": "Can explain when effects run and why",
            "mastered": false
          },
          {
            "criteria": "Can write correct dependency arrays",
            "mastered": false
          },
          {
            "criteria": "Can debug stale closure bugs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Fix incorrect dependency arrays",
            "completed": false
          },
          {
            "task": "Refactor effects to avoid unnecessary re-runs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "useeffect-mental-model",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Overreacted.io - A Complete Guide to useEffect",
          "React Docs - useEffect"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "useEffect Is Not a Lifecycle Method",
          "gist": "Explain effects as synchronization and common dependency mistakes.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T05-ST08",
        "title": "useMemo and useCallback (when they help, when they don't)",
        "details": "Learn how memoization works in React, why premature memoization hurts readability, and when memoization actually prevents expensive recalculations or re-renders.",
        "masteryCriteria": [
          {
            "criteria": "Can explain what useMemo/useCallback do",
            "mastered": false
          },
          {
            "criteria": "Can identify unnecessary memoization",
            "mastered": false
          },
          {
            "criteria": "Can apply memoization in hot paths only",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add memoization to a slow component",
            "completed": false
          },
          {
            "task": "Remove unnecessary memoization elsewhere",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "memoization-tradeoffs",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - useMemo",
          "Kent C. Dodds - When to useMemo"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "useMemo Without Cargo Culting",
          "gist": "Explain when memoization helps and when it's noise.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T05-ST09",
        "title": "Context API performance pitfalls",
        "details": "Understand how context propagation triggers re-renders and why large contexts can degrade performance. Learn strategies to split context and reduce updates.",
        "masteryCriteria": [
          {
            "criteria": "Can explain why context causes re-renders",
            "mastered": false
          },
          {
            "criteria": "Can split context to reduce updates",
            "mastered": false
          },
          {
            "criteria": "Can debug context-related performance issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Profile a large context update",
            "completed": false
          },
          {
            "task": "Refactor into multiple contexts",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "context-performance",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - Context",
          "Overreacted.io - Context Performance"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Context API Performance Pitfalls (And How to Avoid Them)",
          "gist": "Explain context propagation and optimization strategies.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T05-ST10",
        "title": "Compound components pattern",
        "details": "Learn how compound components allow flexible APIs by sharing implicit state via context. Understand tradeoffs compared to prop drilling and render props.",
        "masteryCriteria": [
          {
            "criteria": "Can design a compound component API",
            "mastered": false
          },
          {
            "criteria": "Can manage shared internal state safely",
            "mastered": false
          },
          {
            "criteria": "Can explain tradeoffs vs alternatives",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build a compound component (Tabs, Dropdown)",
            "completed": false
          },
          {
            "task": "Document its public API",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "compound-components",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Kent C. Dodds - Compound Components",
          "React Docs - Composition"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Compound Components: Building Flexible React APIs",
          "gist": "Explain the pattern with a real reusable component.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T05-ST11",
        "title": "Render props pattern",
        "details": "Understand render props as a way to share logic via functions. Learn when this pattern is useful and when hooks have replaced it.",
        "masteryCriteria": [
          {
            "criteria": "Can explain render props",
            "mastered": false
          },
          {
            "criteria": "Can refactor render props to hooks",
            "mastered": false
          },
          {
            "criteria": "Can identify legacy usage",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build a render-prop component",
            "completed": false
          },
          {
            "task": "Refactor it to a custom hook",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "render-props-pattern",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - Render Props",
          "Kent C. Dodds - Render Props"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Render Props: Still Relevant or Legacy?",
          "gist": "Explain render props and how hooks replaced most use cases.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T05-ST12",
        "title": "Error boundaries",
        "details": "Understand how error boundaries catch render-time errors, isolate failures, and prevent full app crashes.",
        "masteryCriteria": [
          {
            "criteria": "Can explain what errors boundaries catch",
            "mastered": false
          },
          {
            "criteria": "Can implement fallback UIs",
            "mastered": false
          },
          {
            "criteria": "Can place boundaries correctly",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add error boundaries to an app",
            "completed": false
          },
          {
            "task": "Simulate component crashes",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "error-boundaries-demo",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - Error Boundaries"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Error Boundaries: Making React Apps Resilient",
          "gist": "Explain error isolation and graceful degradation.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T05-ST13",
        "title": "Suspense mental model",
        "details": "Understand Suspense as a mechanism for coordinating async rendering and loading states, not just a spinner API.",
        "masteryCriteria": [
          {
            "criteria": "Can explain how Suspense pauses rendering",
            "mastered": false
          },
          {
            "criteria": "Can integrate Suspense with data fetching",
            "mastered": false
          },
          {
            "criteria": "Can explain fallback behavior",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Wrap async components in Suspense",
            "completed": false
          },
          {
            "task": "Experiment with nested Suspense boundaries",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "suspense-experiments",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - Suspense",
          "React RFCs - Suspense"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Suspense Explained: Async Rendering Without the Pain",
          "gist": "Explain how Suspense coordinates loading and rendering.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T05-ST14",
        "title": "Concurrent features (conceptual)",
        "details": "Understand the ideas behind concurrent rendering: interruptible work, prioritization, and responsiveness. Focus on concepts rather than APIs.",
        "masteryCriteria": [
          {
            "criteria": "Can explain what concurrent rendering enables",
            "mastered": false
          },
          {
            "criteria": "Can explain why it improves responsiveness",
            "mastered": false
          },
          {
            "criteria": "Can reason about priority-based updates",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Read and summarize concurrent rendering concepts",
            "completed": false
          },
          {
            "task": "Identify UI scenarios that benefit from concurrency",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "concurrent-react-notes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - Concurrent Rendering",
          "React RFCs - Concurrent Mode"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Concurrent React: The Mental Model (Not the APIs)",
          "gist": "Explain concurrency concepts without diving into unstable APIs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T05-ST15",
        "title": "Server vs client components (Next.js)",
        "details": "Understand how server and client components differ, what runs where, data fetching implications, and how this affects performance and architecture.",
        "masteryCriteria": [
          {
            "criteria": "Can explain server vs client component boundaries",
            "mastered": false
          },
          {
            "criteria": "Can decide where logic should live",
            "mastered": false
          },
          {
            "criteria": "Can avoid hydration mismatches",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build a page using both server and client components",
            "completed": false
          },
          {
            "task": "Analyze bundle size differences",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "server-client-components-demo",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Next.js Docs - Server & Client Components",
          "React Docs - Server Components"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Server vs Client Components: A Practical Mental Model",
          "gist": "Explain tradeoffs, performance implications, and architecture decisions.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T06",
    "title": "State Management",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic builds a precise mental model of what state actually is, where it should live, how it should flow, and how to manage it without creating re-render storms, bugs, or unmaintainable architectures. Mastery means you can confidently choose between local state, global state, server state, URL state, derived state, and external stores \u2014 and justify those choices in system design discussions.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P5"
    ],
    "references": [
      "Redux Style Guide",
      "Zustand Documentation",
      "React Docs - State Management",
      "Overreacted.io - You Might Not Need Redux"
    ],
    "subTasks": [
      {
        "id": "T06-ST01",
        "title": "What is state (and what is not)",
        "details": "Understand state as data that changes over time and affects rendering or behavior. Learn to distinguish state from constants, derived values, configuration, and props. This distinction prevents unnecessary state and bugs.",
        "masteryCriteria": [
          {
            "criteria": "Can define state in precise terms",
            "mastered": false
          },
          {
            "criteria": "Can identify unnecessary state",
            "mastered": false
          },
          {
            "criteria": "Can explain why derived values should not be state",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Audit a component and remove unnecessary state",
            "completed": false
          },
          {
            "task": "Refactor derived state into computed values",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "state-vs-derived-audit",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - Thinking in React",
          "Overreacted.io - Don't Sync State"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "What Is State (And What Should Never Be State)",
          "gist": "Explain how overusing state causes bugs and re-renders, with refactoring examples.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T06-ST02",
        "title": "State taxonomy (UI, server, URL, local, global)",
        "details": "Learn to classify state by ownership and lifecycle: UI state (modals, toggles), server state (fetched data), URL state (filters, pagination), local component state, and global shared state. Correct taxonomy prevents misuse of global stores.",
        "masteryCriteria": [
          {
            "criteria": "Can classify any piece of state correctly",
            "mastered": false
          },
          {
            "criteria": "Can explain why server state differs from client state",
            "mastered": false
          },
          {
            "criteria": "Can avoid putting everything in global state",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Classify state in an existing app",
            "completed": false
          },
          {
            "task": "Refactor misclassified state",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "state-taxonomy-map",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Redux Docs - State Structure",
          "Kent C. Dodds - Application State Management"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "State Taxonomy: The Missing Mental Model in React Apps",
          "gist": "Explain different kinds of state and why mixing them causes pain.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T06-ST03",
        "title": "Local state vs lifting state up",
        "details": "Understand when state should stay local and when it should be lifted to a common ancestor. Learn to avoid premature lifting that creates unnecessary coupling.",
        "masteryCriteria": [
          {
            "criteria": "Can decide when to lift state",
            "mastered": false
          },
          {
            "criteria": "Can avoid prop-drilling by design",
            "mastered": false
          },
          {
            "criteria": "Can refactor lifted state back to local",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Refactor a prop-drilled component tree",
            "completed": false
          },
          {
            "task": "Compare local vs lifted implementations",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "lifting-state-experiments",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - Lifting State Up",
          "Overreacted.io - State Colocation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Lifting State Up: When It Helps and When It Hurts",
          "gist": "Explain lifting state tradeoffs with before/after examples.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T06-ST04",
        "title": "Derived state and memoization",
        "details": "Understand derived state as values computed from other state. Learn when memoization is required and when it is unnecessary complexity.",
        "masteryCriteria": [
          {
            "criteria": "Can identify derived state",
            "mastered": false
          },
          {
            "criteria": "Can avoid storing derived values",
            "mastered": false
          },
          {
            "criteria": "Can apply memoization only when needed",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Remove derived state and replace with computation",
            "completed": false
          },
          {
            "task": "Benchmark memoized vs non-memoized code",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "derived-state-memoization",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Docs - You Probably Don't Need Derived State",
          "Kent C. Dodds - useMemo Advice"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Derived State Is a Code Smell (Most of the Time)",
          "gist": "Explain why derived state causes bugs and how memoization fits in.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T06-ST05",
        "title": "Global state: when it is justified",
        "details": "Learn the narrow set of cases where global state is actually needed: auth, theme, feature flags, cross-cutting app concerns. Avoid turning global state into a dumping ground.",
        "masteryCriteria": [
          {
            "criteria": "Can justify global state usage",
            "mastered": false
          },
          {
            "criteria": "Can explain costs of global state",
            "mastered": false
          },
          {
            "criteria": "Can remove unnecessary global stores",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Audit a global store and reduce scope",
            "completed": false
          },
          {
            "task": "Split unrelated global concerns",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "global-state-audit",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Redux Style Guide",
          "Overreacted.io - You Might Not Need Redux"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "When Global State Is Actually the Right Choice",
          "gist": "Explain legitimate global state use cases vs misuse.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T06-ST06",
        "title": "Redux fundamentals (modern Redux Toolkit)",
        "details": "Understand Redux as a predictable state container with unidirectional data flow. Focus on Redux Toolkit: slices, reducers, actions, immutability, and store setup.",
        "masteryCriteria": [
          {
            "criteria": "Can explain Redux data flow",
            "mastered": false
          },
          {
            "criteria": "Can build slices using Redux Toolkit",
            "mastered": false
          },
          {
            "criteria": "Can debug Redux state changes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build a small app using Redux Toolkit",
            "completed": false
          },
          {
            "task": "Inspect state changes using Redux DevTools",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "redux-toolkit-fundamentals",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Redux Toolkit Docs",
          "Redux Essentials Tutorial"
        ],
        "estimatedHours": 5,
        "status": "not-started",
        "blog": {
          "title": "Redux Without the Boilerplate: Redux Toolkit Explained",
          "gist": "Explain modern Redux patterns and why older patterns are obsolete.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T06-ST07",
        "title": "Redux selectors and performance",
        "details": "Learn how selectors control re-renders, why memoized selectors matter, and how poorly designed selectors cause performance issues.",
        "masteryCriteria": [
          {
            "criteria": "Can write efficient selectors",
            "mastered": false
          },
          {
            "criteria": "Can explain selector memoization",
            "mastered": false
          },
          {
            "criteria": "Can debug unnecessary re-renders",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Optimize selectors using reselect",
            "completed": false
          },
          {
            "task": "Measure render count before and after",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "redux-selectors-performance",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Redux Docs - Selectors",
          "Reselect Documentation"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Redux Selectors: The Hidden Performance Lever",
          "gist": "Explain how selectors influence rendering behavior.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T06-ST08",
        "title": "Zustand fundamentals and philosophy",
        "details": "Understand Zustand as a minimal, unopinionated state store. Learn how it differs from Redux in architecture, mental model, and performance.",
        "masteryCriteria": [
          {
            "criteria": "Can explain Zustand's mental model",
            "mastered": false
          },
          {
            "criteria": "Can build a store with actions",
            "mastered": false
          },
          {
            "criteria": "Can explain tradeoffs vs Redux",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Rewrite a Redux store using Zustand",
            "completed": false
          },
          {
            "task": "Compare complexity and DX",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "zustand-fundamentals",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Zustand Documentation",
          "Zustand GitHub Discussions"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Zustand vs Redux: Two Very Different State Philosophies",
          "gist": "Compare architecture, performance, and DX tradeoffs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T06-ST09",
        "title": "Avoiding re-render storms",
        "details": "Learn how state updates propagate re-renders, common causes of re-render storms, and techniques to isolate updates.",
        "masteryCriteria": [
          {
            "criteria": "Can identify re-render storms",
            "mastered": false
          },
          {
            "criteria": "Can isolate state updates",
            "mastered": false
          },
          {
            "criteria": "Can use memoization and store selectors effectively",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Profile re-renders using DevTools",
            "completed": false
          },
          {
            "task": "Fix excessive re-renders",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "rerender-storm-fixes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React DevTools Profiler",
          "Overreacted.io - Fixing Re-renders"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Re-render Storms: Why Your App Feels Slow",
          "gist": "Explain how state updates cascade and how to stop them.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T06-ST10",
        "title": "State debugging techniques",
        "details": "Learn systematic ways to debug state issues: time-travel debugging, logging, DevTools inspection, and reasoning about state transitions.",
        "masteryCriteria": [
          {
            "criteria": "Can debug incorrect state transitions",
            "mastered": false
          },
          {
            "criteria": "Can use DevTools effectively",
            "mastered": false
          },
          {
            "criteria": "Can explain bugs using state flow diagrams",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Debug a broken state flow",
            "completed": false
          },
          {
            "task": "Document state transitions visually",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "state-debugging-playbook",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Redux DevTools",
          "React DevTools"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "How to Debug State Bugs Without Guessing",
          "gist": "Explain a systematic approach to state debugging.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T07",
    "title": "Styling & UI Architecture",
    "parentTopic": null,
    "priority": "medium",
    "difficulty": "medium",
    "details": "This topic focuses on building predictable, scalable, and accessible styling systems for modern web applications. Mastery means you can reason about CSS behavior, choose the right layout tools, design themeable components, and avoid long-term styling debt.",
    "projectsCoveredIn": [
      "P1",
      "P5"
    ],
    "references": [
      "MDN CSS Documentation",
      "WCAG Accessibility Guidelines",
      "Josh Comeau - CSS for JavaScript Developers"
    ],
    "subTasks": [
      {
        "id": "T07-ST01",
        "title": "CSS fundamentals (specificity, cascade)",
        "details": "Understand how the CSS cascade resolves conflicts between rules, how specificity is calculated, and how inheritance works. Focus on predicting which rule wins without relying on trial-and-error or `!important`.",
        "masteryCriteria": [
          {
            "criteria": "Can predict which CSS rule will apply",
            "mastered": false
          },
          {
            "criteria": "Can refactor styles to reduce specificity",
            "mastered": false
          },
          {
            "criteria": "Can avoid using `!important` in normal cases",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze conflicting CSS rules and predict outcomes",
            "completed": false
          },
          {
            "task": "Refactor a stylesheet to lower specificity",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "css-cascade-specificity-examples",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Cascade and Specificity",
          "Josh Comeau - CSS Specificity"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "CSS Specificity and Cascade Explained Without Guesswork",
          "gist": "Explain how the cascade and specificity actually work using real debugging scenarios.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T07-ST02",
        "title": "Flexbox vs Grid (when to use what)",
        "details": "Learn the mental models of Flexbox (one-dimensional layout) and Grid (two-dimensional layout). Focus on choosing the right tool based on layout intent rather than habit.",
        "masteryCriteria": [
          {
            "criteria": "Can explain Flexbox vs Grid differences",
            "mastered": false
          },
          {
            "criteria": "Can choose the correct layout system",
            "mastered": false
          },
          {
            "criteria": "Can avoid overusing one for all layouts",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build the same layout using Flexbox and Grid",
            "completed": false
          },
          {
            "task": "Explain which approach is better and why",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "flexbox-vs-grid-layouts",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Flexbox",
          "MDN - CSS Grid"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Flexbox vs Grid: Choosing the Right Layout Tool",
          "gist": "Compare layout intent, constraints, and real-world use cases.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T07-ST03",
        "title": "Responsive design strategies",
        "details": "Understand responsive design beyond media queries: fluid layouts, content-driven breakpoints, intrinsic sizing, and container-based responsiveness.",
        "masteryCriteria": [
          {
            "criteria": "Can design layouts that adapt naturally",
            "mastered": false
          },
          {
            "criteria": "Can avoid device-specific breakpoints",
            "mastered": false
          },
          {
            "criteria": "Can reason about content-driven responsiveness",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build a responsive page with minimal media queries",
            "completed": false
          },
          {
            "task": "Refactor a fixed layout into a fluid one",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "responsive-design-strategies",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Responsive Design",
          "Every Layout - Responsive Patterns"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Responsive Design Without Chasing Screen Sizes",
          "gist": "Explain modern responsive strategies and why device-based breakpoints fail.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T07-ST04",
        "title": "Design tokens",
        "details": "Learn to represent design decisions (colors, spacing, typography) as data through design tokens. Focus on consistency, scalability, and cross-platform reuse.",
        "masteryCriteria": [
          {
            "criteria": "Can explain what design tokens are",
            "mastered": false
          },
          {
            "criteria": "Can define token hierarchies",
            "mastered": false
          },
          {
            "criteria": "Can consume tokens in components",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create a token system for colors and spacing",
            "completed": false
          },
          {
            "task": "Refactor hardcoded styles to tokens",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "design-tokens-system",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "W3C Design Tokens Community Group",
          "Material Design - Design Tokens"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Design Tokens: Turning Design Decisions Into Code",
          "gist": "Explain why tokens beat hardcoded values in scalable UI systems.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T07-ST05",
        "title": "Component theming",
        "details": "Understand how to theme components using tokens, context, or configuration. Focus on making components customizable without coupling them to global styles.",
        "masteryCriteria": [
          {
            "criteria": "Can design themeable components",
            "mastered": false
          },
          {
            "criteria": "Can avoid theme leakage",
            "mastered": false
          },
          {
            "criteria": "Can support multiple themes safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add theming support to a component library",
            "completed": false
          },
          {
            "task": "Switch themes without changing component logic",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "component-theming",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MUI Theming Docs",
          "Styled Systems Concepts"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Component Theming Without Breaking Encapsulation",
          "gist": "Explain how to make components theme-aware but not theme-dependent.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T07-ST06",
        "title": "CSS-in-JS tradeoffs",
        "details": "Understand CSS-in-JS as a pattern, not a tool. Learn runtime vs build-time approaches, performance implications, and debugging tradeoffs.",
        "masteryCriteria": [
          {
            "criteria": "Can explain CSS-in-JS tradeoffs",
            "mastered": false
          },
          {
            "criteria": "Can identify runtime costs",
            "mastered": false
          },
          {
            "criteria": "Can choose CSS-in-JS appropriately",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Style a component using CSS-in-JS",
            "completed": false
          },
          {
            "task": "Measure bundle size and runtime impact",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "css-in-js-tradeoffs",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Styled-components Docs",
          "Vanilla Extract Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "CSS-in-JS: Power, Costs, and Tradeoffs",
          "gist": "Explain when CSS-in-JS helps and when it creates unnecessary overhead.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T07-ST07",
        "title": "Tailwind pros/cons",
        "details": "Understand Tailwind as a utility-first approach. Learn its productivity benefits, readability tradeoffs, and long-term maintainability considerations.",
        "masteryCriteria": [
          {
            "criteria": "Can explain Tailwind's philosophy",
            "mastered": false
          },
          {
            "criteria": "Can articulate pros and cons",
            "mastered": false
          },
          {
            "criteria": "Can decide when Tailwind fits a team",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build a UI using Tailwind",
            "completed": false
          },
          {
            "task": "Refactor a component to reduce class noise",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "tailwind-evaluation",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Tailwind CSS Documentation",
          "Adam Wathan - Utility-First CSS"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Tailwind CSS: Productivity Boost or Maintainability Risk?",
          "gist": "Evaluate Tailwind honestly with real-world tradeoffs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T07-ST08",
        "title": "Accessibility (ARIA, keyboard nav)",
        "details": "Learn accessibility fundamentals: semantic HTML, ARIA roles, keyboard navigation, focus management, and screen reader behavior.",
        "masteryCriteria": [
          {
            "criteria": "Can build keyboard-accessible components",
            "mastered": false
          },
          {
            "criteria": "Can use ARIA correctly",
            "mastered": false
          },
          {
            "criteria": "Can identify common a11y issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Audit a UI for keyboard and ARIA issues",
            "completed": false
          },
          {
            "task": "Fix focus management problems",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "accessibility-fixes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "WCAG 2.x Guidelines",
          "MDN - ARIA"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Accessibility Basics Every Frontend Developer Must Know",
          "gist": "Explain ARIA, keyboard navigation, and common accessibility mistakes.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T07-ST09",
        "title": "Dark mode architecture",
        "details": "Understand dark mode as a theming and token problem, not a CSS override hack. Learn how to support system preferences and user overrides cleanly.",
        "masteryCriteria": [
          {
            "criteria": "Can implement dark mode cleanly",
            "mastered": false
          },
          {
            "criteria": "Can support system and user preferences",
            "mastered": false
          },
          {
            "criteria": "Can avoid duplicated styles",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add dark mode using tokens",
            "completed": false
          },
          {
            "task": "Support prefers-color-scheme",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "dark-mode-architecture",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - prefers-color-scheme",
          "Material Design - Dark Theme"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Dark Mode Done Right: Architecture, Not Hacks",
          "gist": "Explain why dark mode should be built on tokens and themes.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T08",
    "title": "Build Tools & Module Systems",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic explains why build tools exist, how modern JavaScript modules work, and how bundlers transform source code into production-ready assets. Mastery means you can debug build issues, optimize bundles, and reason about performance, compatibility, and developer experience.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P5"
    ],
    "references": [
      "MDN - JavaScript Modules",
      "Vite Documentation",
      "Webpack Documentation",
      "SurviveJS - Webpack"
    ],
    "subTasks": [
      {
        "id": "T08-ST01",
        "title": "Why bundlers exist",
        "details": "Understand the historical and technical reasons bundlers exist: module resolution, dependency graphs, performance optimization, browser limitations, and developer ergonomics.",
        "masteryCriteria": [
          {
            "criteria": "Can explain why browsers originally needed bundlers",
            "mastered": false
          },
          {
            "criteria": "Can explain what problems bundlers solve",
            "mastered": false
          },
          {
            "criteria": "Can explain why some bundling is still required today",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build a small app without a bundler",
            "completed": false
          },
          {
            "task": "Identify limitations and pain points",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "why-bundlers-exist",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - JavaScript Modules",
          "SurviveJS - Why Bundle"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Why JavaScript Bundlers Exist (And Why They Still Matter)",
          "gist": "Explain the problems bundlers solve and why they didn't disappear with modern browsers.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T08-ST02",
        "title": "ESM vs CommonJS",
        "details": "Understand the differences between ES Modules and CommonJS: syntax, loading behavior, static vs dynamic analysis, and ecosystem implications.",
        "masteryCriteria": [
          {
            "criteria": "Can explain ESM and CommonJS differences",
            "mastered": false
          },
          {
            "criteria": "Can explain why ESM enables tree shaking",
            "mastered": false
          },
          {
            "criteria": "Can debug interop issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Convert a CommonJS project to ESM",
            "completed": false
          },
          {
            "task": "Fix mixed-module issues",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "esm-vs-commonjs",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Node.js Docs - Modules",
          "MDN - ES Modules"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "ESM vs CommonJS: What Actually Changes Under the Hood",
          "gist": "Explain loading, syntax, and why modern tooling prefers ESM.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T08-ST03",
        "title": "Vite internals (dev server, HMR)",
        "details": "Understand how Vite uses native ESM in development, how its dev server works, and how HMR achieves fast feedback loops.",
        "masteryCriteria": [
          {
            "criteria": "Can explain why Vite is fast in dev",
            "mastered": false
          },
          {
            "criteria": "Can explain Vite's HMR mechanism",
            "mastered": false
          },
          {
            "criteria": "Can debug Vite-specific issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Inspect network requests in Vite dev server",
            "completed": false
          },
          {
            "task": "Trigger and observe HMR updates",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "vite-internals-experiments",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Vite Documentation",
          "Vite GitHub Discussions"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "How Vite Works Under the Hood",
          "gist": "Explain dev-time ESM, HMR, and why Vite feels instant.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T08-ST04",
        "title": "Webpack internals (loaders, plugins)",
        "details": "Understand Webpack's architecture: dependency graph, loaders for transformation, plugins for lifecycle hooks, and the compilation pipeline.",
        "masteryCriteria": [
          {
            "criteria": "Can explain loaders vs plugins",
            "mastered": false
          },
          {
            "criteria": "Can explain Webpack's build lifecycle",
            "mastered": false
          },
          {
            "criteria": "Can debug complex Webpack configs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write a custom loader",
            "completed": false
          },
          {
            "task": "Write a simple Webpack plugin",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "webpack-internals",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Webpack Documentation",
          "SurviveJS - Webpack Internals"
        ],
        "estimatedHours": 5,
        "status": "not-started",
        "blog": {
          "title": "Webpack Internals: Loaders, Plugins, and the Build Pipeline",
          "gist": "Explain how Webpack processes files step by step.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T08-ST05",
        "title": "Tree shaking",
        "details": "Understand tree shaking as dead code elimination based on static analysis. Learn why ESM is required and what patterns break tree shaking.",
        "masteryCriteria": [
          {
            "criteria": "Can explain how tree shaking works",
            "mastered": false
          },
          {
            "criteria": "Can identify tree-shaking blockers",
            "mastered": false
          },
          {
            "criteria": "Can write tree-shakable code",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build a tree-shakable library",
            "completed": false
          },
          {
            "task": "Analyze output bundles",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "tree-shaking-experiments",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Webpack Docs - Tree Shaking",
          "Rollup Tree Shaking Guide"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Tree Shaking Explained: Why Your Code Isn't Getting Removed",
          "gist": "Explain static analysis, ESM, and common pitfalls.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T08-ST06",
        "title": "Code splitting",
        "details": "Understand how code splitting breaks bundles into smaller chunks to improve initial load performance and caching.",
        "masteryCriteria": [
          {
            "criteria": "Can explain why code splitting improves performance",
            "mastered": false
          },
          {
            "criteria": "Can design chunk boundaries",
            "mastered": false
          },
          {
            "criteria": "Can avoid over-splitting",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Split a large bundle into route-based chunks",
            "completed": false
          },
          {
            "task": "Measure load-time improvements",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "code-splitting-strategies",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Webpack Docs - Code Splitting",
          "web.dev - Reduce JavaScript Payloads"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Code Splitting: Faster Loads Through Smarter Bundles",
          "gist": "Explain chunking strategies and performance tradeoffs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T08-ST07",
        "title": "Dynamic imports",
        "details": "Understand dynamic imports as a runtime mechanism for loading code on demand and their role in code splitting.",
        "masteryCriteria": [
          {
            "criteria": "Can use dynamic imports correctly",
            "mastered": false
          },
          {
            "criteria": "Can explain runtime loading behavior",
            "mastered": false
          },
          {
            "criteria": "Can avoid waterfall loading issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement dynamic imports for routes",
            "completed": false
          },
          {
            "task": "Inspect chunk loading behavior",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "dynamic-imports",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Dynamic Imports",
          "Webpack Docs - import()"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Dynamic Imports: Loading Code Only When Needed",
          "gist": "Explain runtime imports and how bundlers handle them.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T08-ST08",
        "title": "Polyfills",
        "details": "Understand polyfills as runtime feature replacements. Learn how bundlers and tools decide what to polyfill and the cost of over-polyfilling.",
        "masteryCriteria": [
          {
            "criteria": "Can explain what polyfills do",
            "mastered": false
          },
          {
            "criteria": "Can configure polyfills correctly",
            "mastered": false
          },
          {
            "criteria": "Can avoid unnecessary polyfills",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Configure polyfills for older browsers",
            "completed": false
          },
          {
            "task": "Compare bundle sizes with and without polyfills",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "polyfill-configuration",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Polyfills",
          "core-js Documentation"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Polyfills: Compatibility Without Bloat",
          "gist": "Explain when polyfills are needed and how to limit their cost.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T08-ST09",
        "title": "Environment variables",
        "details": "Understand how environment variables are injected at build time, their limitations, and how to avoid leaking secrets to the client.",
        "masteryCriteria": [
          {
            "criteria": "Can explain build-time vs runtime env vars",
            "mastered": false
          },
          {
            "criteria": "Can avoid exposing secrets",
            "mastered": false
          },
          {
            "criteria": "Can configure envs for multiple environments",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Configure env variables for dev/stage/prod",
            "completed": false
          },
          {
            "task": "Audit client bundles for leaked secrets",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "env-vars-setup",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Vite - Env Variables",
          "Webpack - DefinePlugin"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Environment Variables in Frontend Builds Explained",
          "gist": "Explain how env vars work and common security mistakes.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T08-ST10",
        "title": "Source maps",
        "details": "Understand how source maps map compiled code back to original sources, how they affect debugging and performance, and when to disable them.",
        "masteryCriteria": [
          {
            "criteria": "Can explain how source maps work",
            "mastered": false
          },
          {
            "criteria": "Can debug production issues using source maps",
            "mastered": false
          },
          {
            "criteria": "Can choose appropriate source map types",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Debug a minified error using source maps",
            "completed": false
          },
          {
            "task": "Compare different source map modes",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "source-maps-debugging",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Source Maps",
          "Webpack Docs - devtool"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Source Maps: Debugging Production Without Losing Your Mind",
          "gist": "Explain source maps and how to use them safely.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T08-ST11",
        "title": "Bundle analysis",
        "details": "Learn to inspect bundle contents, identify large dependencies, and make data-driven optimization decisions.",
        "masteryCriteria": [
          {
            "criteria": "Can analyze bundle composition",
            "mastered": false
          },
          {
            "criteria": "Can identify unnecessary dependencies",
            "mastered": false
          },
          {
            "criteria": "Can reduce bundle size intentionally",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Run a bundle analyzer",
            "completed": false
          },
          {
            "task": "Remove or replace heavy dependencies",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "bundle-analysis",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Webpack Bundle Analyzer",
          "Vite - Visualizer Plugin"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Bundle Analysis: Finding What's Actually Making Your App Heavy",
          "gist": "Show how to analyze bundles and act on findings.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T08-ST12",
        "title": "Build caching",
        "details": "Understand build caching mechanisms that speed up rebuilds by reusing previous outputs, both locally and in CI.",
        "masteryCriteria": [
          {
            "criteria": "Can explain build caching",
            "mastered": false
          },
          {
            "criteria": "Can configure caching correctly",
            "mastered": false
          },
          {
            "criteria": "Can debug cache-related issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Enable build caching locally",
            "completed": false
          },
          {
            "task": "Measure rebuild speed improvements",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "build-caching",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Webpack - Persistent Caching",
          "Nx - Build Caching Concepts"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Build Caching: Making Builds Fast Without Cutting Corners",
          "gist": "Explain caching concepts and why they matter at scale.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T09",
    "title": "Networking & Web Protocols (Non-negotiable)",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic builds a deep, practical understanding of how web communication works from the browser to the server. Mastery means you can debug production issues, design resilient APIs, choose the right communication model, and reason about failures, retries, and security without guesswork.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P5"
    ],
    "references": [
      "MDN - HTTP",
      "web.dev - Networking",
      "High Performance Browser Networking - Ilya Grigorik"
    ],
    "subTasks": [
      {
        "id": "T09-ST01",
        "title": "HTTP fundamentals",
        "details": "Understand HTTP as a stateless request-response protocol: methods, resources, URLs, and how clients and servers communicate over TCP/IP.",
        "masteryCriteria": [
          {
            "criteria": "Can explain how HTTP works at a high level",
            "mastered": false
          },
          {
            "criteria": "Can explain statelessness",
            "mastered": false
          },
          {
            "criteria": "Can differentiate common HTTP methods",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Inspect HTTP requests using browser DevTools",
            "completed": false
          },
          {
            "task": "Manually craft HTTP requests using curl",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "http-fundamentals",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - HTTP Overview",
          "RFC 9110 (overview sections)"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "HTTP Fundamentals Every Web Developer Must Know",
          "gist": "Explain how HTTP works and why it underpins all web communication.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST02",
        "title": "Request lifecycle",
        "details": "Understand the full lifecycle of a web request: DNS lookup, TCP handshake, TLS negotiation, request dispatch, server processing, and response handling.",
        "masteryCriteria": [
          {
            "criteria": "Can explain each step of the request lifecycle",
            "mastered": false
          },
          {
            "criteria": "Can identify where latency occurs",
            "mastered": false
          },
          {
            "criteria": "Can diagnose slow requests",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Trace a request using DevTools timing tab",
            "completed": false
          },
          {
            "task": "Map latency contributors for a slow endpoint",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "request-lifecycle-map",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "web.dev - Request Lifecycle",
          "High Performance Browser Networking"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "The Complete Lifecycle of a Web Request",
          "gist": "Walk through a request from browser to server and back.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST03",
        "title": "Headers deep dive",
        "details": "Understand HTTP headers as metadata: request headers, response headers, caching headers, security headers, and content negotiation.",
        "masteryCriteria": [
          {
            "criteria": "Can explain common headers and their purpose",
            "mastered": false
          },
          {
            "criteria": "Can debug header-related issues",
            "mastered": false
          },
          {
            "criteria": "Can configure headers intentionally",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Inspect request/response headers",
            "completed": false
          },
          {
            "task": "Configure cache and security headers",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "http-headers-experiments",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - HTTP Headers",
          "OWASP Secure Headers Project"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "HTTP Headers: The Hidden Control Layer of the Web",
          "gist": "Explain how headers influence caching, security, and behavior.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST04",
        "title": "Status codes meaningfully",
        "details": "Learn to use HTTP status codes intentionally to communicate outcomes, errors, and retry semantics clearly to clients.",
        "masteryCriteria": [
          {
            "criteria": "Can choose correct status codes",
            "mastered": false
          },
          {
            "criteria": "Can explain client behavior implications",
            "mastered": false
          },
          {
            "criteria": "Can avoid misleading status usage",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Refactor API responses to correct status codes",
            "completed": false
          },
          {
            "task": "Document API error responses",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "http-status-codes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - HTTP Status Codes",
          "RFC 9110 - Status Codes"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "HTTP Status Codes: Communicating Meaning, Not Just Errors",
          "gist": "Explain how proper status codes improve API clarity and reliability.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST05",
        "title": "CORS & preflight",
        "details": "Understand the browser security model, same-origin policy, CORS headers, and how preflight requests work.",
        "masteryCriteria": [
          {
            "criteria": "Can explain why CORS exists",
            "mastered": false
          },
          {
            "criteria": "Can debug CORS errors",
            "mastered": false
          },
          {
            "criteria": "Can configure CORS safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Trigger a preflight request intentionally",
            "completed": false
          },
          {
            "task": "Fix a broken CORS setup",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "cors-preflight-debugging",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - CORS",
          "web.dev - CORS"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "CORS and Preflight Requests Explained Clearly",
          "gist": "Explain browser enforcement, headers, and common pitfalls.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST06",
        "title": "Cookies vs tokens",
        "details": "Understand session-based auth with cookies vs token-based auth (JWT, opaque tokens), including security tradeoffs and storage implications.",
        "masteryCriteria": [
          {
            "criteria": "Can explain cookies vs tokens",
            "mastered": false
          },
          {
            "criteria": "Can choose auth strategy appropriately",
            "mastered": false
          },
          {
            "criteria": "Can explain XSS vs CSRF implications",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement cookie-based auth",
            "completed": false
          },
          {
            "task": "Implement token-based auth and compare",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "cookies-vs-tokens",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OWASP - Authentication Cheat Sheet",
          "MDN - Cookies"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Cookies vs Tokens: Choosing the Right Auth Strategy",
          "gist": "Compare security, storage, and architectural tradeoffs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST07",
        "title": "HTTPS & TLS (high level)",
        "details": "Understand HTTPS as HTTP over TLS, including encryption, certificates, and trust chains at a conceptual level.",
        "masteryCriteria": [
          {
            "criteria": "Can explain what TLS provides",
            "mastered": false
          },
          {
            "criteria": "Can explain certificate trust",
            "mastered": false
          },
          {
            "criteria": "Can explain why HTTPS is mandatory",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Inspect TLS details of a site",
            "completed": false
          },
          {
            "task": "Explain a certificate chain",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "https-tls-basics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - HTTPS",
          "Cloudflare - TLS Explained"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "HTTPS and TLS: What Every Web Developer Should Understand",
          "gist": "Explain encryption, certificates, and trust without cryptography deep dives.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST08",
        "title": "REST design principles",
        "details": "Understand REST as an architectural style: resources, representations, statelessness, and uniform interfaces.",
        "masteryCriteria": [
          {
            "criteria": "Can design RESTful endpoints",
            "mastered": false
          },
          {
            "criteria": "Can explain REST constraints",
            "mastered": false
          },
          {
            "criteria": "Can avoid RPC-style REST",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Design a REST API from scratch",
            "completed": false
          },
          {
            "task": "Refactor non-RESTful endpoints",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "rest-design-principles",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "RESTful API Design - Best Practices",
          "Roy Fielding Dissertation (high-level)"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "REST API Design: Principles That Actually Matter",
          "gist": "Explain REST concepts with practical API examples.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST09",
        "title": "Pagination & filtering",
        "details": "Understand pagination strategies (offset, cursor) and filtering patterns for scalable APIs.",
        "masteryCriteria": [
          {
            "criteria": "Can implement pagination correctly",
            "mastered": false
          },
          {
            "criteria": "Can choose offset vs cursor",
            "mastered": false
          },
          {
            "criteria": "Can design filterable endpoints",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement cursor-based pagination",
            "completed": false
          },
          {
            "task": "Design filter parameters",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "pagination-filtering",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Stripe API Pagination",
          "API Design Guidelines"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Pagination and Filtering: Scaling API Responses",
          "gist": "Explain pagination strategies and tradeoffs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST10",
        "title": "Idempotency",
        "details": "Understand idempotent operations and why they matter for retries, failures, and distributed systems.",
        "masteryCriteria": [
          {
            "criteria": "Can explain idempotency",
            "mastered": false
          },
          {
            "criteria": "Can design idempotent APIs",
            "mastered": false
          },
          {
            "criteria": "Can handle retries safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add idempotency keys to an endpoint",
            "completed": false
          },
          {
            "task": "Simulate retry scenarios",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "idempotent-apis",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Stripe - Idempotency Keys",
          "RFC 9110 - Method Semantics"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Idempotency: The Unsung Hero of Reliable APIs",
          "gist": "Explain why idempotency prevents duplicate actions.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST11",
        "title": "Rate limiting",
        "details": "Understand rate limiting as a protective mechanism against abuse and overload. Learn common strategies and headers.",
        "masteryCriteria": [
          {
            "criteria": "Can explain rate limiting strategies",
            "mastered": false
          },
          {
            "criteria": "Can implement rate limits",
            "mastered": false
          },
          {
            "criteria": "Can communicate limits to clients",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add rate limiting middleware",
            "completed": false
          },
          {
            "task": "Test limit exceed scenarios",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "rate-limiting",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "IETF RateLimit Headers Draft",
          "NGINX Rate Limiting Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Rate Limiting: Protecting APIs Without Breaking Clients",
          "gist": "Explain rate limiting strategies and API communication.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST12",
        "title": "WebSockets",
        "details": "Understand WebSockets as a persistent, bidirectional communication channel and when they are appropriate.",
        "masteryCriteria": [
          {
            "criteria": "Can explain WebSocket lifecycle",
            "mastered": false
          },
          {
            "criteria": "Can implement basic WebSocket communication",
            "mastered": false
          },
          {
            "criteria": "Can identify suitable use cases",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build a WebSocket-based chat",
            "completed": false
          },
          {
            "task": "Handle reconnect logic",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "websocket-basics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - WebSockets",
          "RFC 6455"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "WebSockets: Real-Time Communication on the Web",
          "gist": "Explain persistent connections and real-time use cases.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST13",
        "title": "SSE",
        "details": "Understand Server-Sent Events as a one-way streaming protocol over HTTP and how it compares to WebSockets.",
        "masteryCriteria": [
          {
            "criteria": "Can explain SSE mechanics",
            "mastered": false
          },
          {
            "criteria": "Can implement SSE",
            "mastered": false
          },
          {
            "criteria": "Can choose SSE vs WebSockets",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement an SSE endpoint",
            "completed": false
          },
          {
            "task": "Consume SSE from the browser",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "sse-demo",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Server-Sent Events",
          "HTML Living Standard - SSE"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Server-Sent Events: Simpler Real-Time Updates",
          "gist": "Explain when SSE is a better choice than WebSockets.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST14",
        "title": "Polling vs streaming",
        "details": "Compare polling, long polling, SSE, and WebSockets in terms of latency, scalability, and complexity.",
        "masteryCriteria": [
          {
            "criteria": "Can explain polling vs streaming",
            "mastered": false
          },
          {
            "criteria": "Can choose the right approach",
            "mastered": false
          },
          {
            "criteria": "Can explain scalability implications",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement polling and streaming versions",
            "completed": false
          },
          {
            "task": "Compare network usage",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "polling-vs-streaming",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "web.dev - Real-Time Communication",
          "MDN - Networking APIs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Polling vs Streaming: Choosing the Right Real-Time Strategy",
          "gist": "Compare real-time communication models clearly.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST15",
        "title": "Retries & backoff",
        "details": "Understand retry strategies, exponential backoff, jitter, and how retries interact with idempotency.",
        "masteryCriteria": [
          {
            "criteria": "Can implement retries safely",
            "mastered": false
          },
          {
            "criteria": "Can explain backoff strategies",
            "mastered": false
          },
          {
            "criteria": "Can avoid retry storms",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add retry logic with backoff",
            "completed": false
          },
          {
            "task": "Simulate flaky network conditions",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "retries-backoff",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS Architecture - Retry Strategies",
          "Google SRE - Backoff"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Retries and Backoff: Making Networks Reliable",
          "gist": "Explain retry strategies and failure handling.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST16",
        "title": "Axios internals",
        "details": "Understand how Axios wraps XMLHttpRequest/fetch, interceptors, request/response pipelines, and error handling.",
        "masteryCriteria": [
          {
            "criteria": "Can explain Axios request flow",
            "mastered": false
          },
          {
            "criteria": "Can use interceptors correctly",
            "mastered": false
          },
          {
            "criteria": "Can debug Axios issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement Axios interceptors",
            "completed": false
          },
          {
            "task": "Trace a request through Axios",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "axios-internals",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Axios GitHub Repository",
          "Axios Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Axios Internals: More Than Just HTTP Requests",
          "gist": "Explain Axios pipelines and interception.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T09-ST17",
        "title": "Request cancellation",
        "details": "Understand request cancellation using AbortController, why it matters for UX and resource usage, and how libraries implement it.",
        "masteryCriteria": [
          {
            "criteria": "Can cancel in-flight requests",
            "mastered": false
          },
          {
            "criteria": "Can prevent race conditions",
            "mastered": false
          },
          {
            "criteria": "Can explain cancellation semantics",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Cancel requests on route change",
            "completed": false
          },
          {
            "task": "Prevent stale data updates",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "request-cancellation",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - AbortController",
          "Axios Cancellation Docs"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Request Cancellation: Avoiding Stale and Wasted Network Calls",
          "gist": "Explain AbortController and practical cancellation scenarios.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T10",
    "title": "Backend Fundamentals (Node.js & APIs)",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic establishes strong backend fundamentals using Node.js and HTTP APIs. Mastery means you can reason about concurrency, performance, correctness, and reliability; design clean API layers; and handle authentication, authorization, background work, and versioning without ad-hoc solutions.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P5"
    ],
    "references": [
      "Node.js Documentation",
      "Express Documentation",
      "OWASP API Security Top 10"
    ],
    "subTasks": [
      {
        "id": "T10-ST01",
        "title": "Node event loop",
        "details": "Understand Node.js's event loop phases, how callbacks are scheduled, and how timers, I/O, microtasks, and nextTick interact in a server environment.",
        "masteryCriteria": [
          {
            "criteria": "Can explain event loop phases",
            "mastered": false
          },
          {
            "criteria": "Can predict execution order",
            "mastered": false
          },
          {
            "criteria": "Can diagnose event-loop blocking",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write code to observe event loop phases",
            "completed": false
          },
          {
            "task": "Analyze blocking behavior",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "node-event-loop",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Node.js Docs - Event Loop",
          "libuv Design Overview"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "The Node.js Event Loop Explained for Backend Developers",
          "gist": "Explain event loop phases and why they matter for server performance.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T10-ST02",
        "title": "Async IO vs CPU tasks",
        "details": "Understand how Node handles asynchronous I/O efficiently and why CPU-bound work blocks the event loop. Learn when to use worker threads or external services.",
        "masteryCriteria": [
          {
            "criteria": "Can distinguish I/O vs CPU-bound tasks",
            "mastered": false
          },
          {
            "criteria": "Can prevent event loop blocking",
            "mastered": false
          },
          {
            "criteria": "Can offload CPU work safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Benchmark CPU-heavy vs async I/O tasks",
            "completed": false
          },
          {
            "task": "Move CPU work to worker threads",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "async-io-vs-cpu",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Node.js Docs - Worker Threads",
          "libuv Thread Pool"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Async I/O vs CPU Tasks in Node.js",
          "gist": "Explain why Node excels at I/O and struggles with CPU-heavy work.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T10-ST03",
        "title": "Express internals",
        "details": "Understand Express as a minimal routing and middleware framework: request/response objects, routing, and lifecycle.",
        "masteryCriteria": [
          {
            "criteria": "Can explain Express request lifecycle",
            "mastered": false
          },
          {
            "criteria": "Can reason about routing resolution",
            "mastered": false
          },
          {
            "criteria": "Can debug Express behavior",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Trace a request through Express",
            "completed": false
          },
          {
            "task": "Inspect req/res mutation",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "express-internals",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Express Documentation",
          "Express Source Code (high level)"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Express Internals: What Actually Happens on a Request",
          "gist": "Explain Express lifecycle from request to response.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T10-ST04",
        "title": "Middleware chains",
        "details": "Understand middleware as a chain of responsibility: execution order, short-circuiting, and error propagation.",
        "masteryCriteria": [
          {
            "criteria": "Can design middleware chains",
            "mastered": false
          },
          {
            "criteria": "Can control execution flow",
            "mastered": false
          },
          {
            "criteria": "Can debug ordering issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write custom middleware",
            "completed": false
          },
          {
            "task": "Reorder middleware and observe behavior",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "middleware-chains",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Express Docs - Middleware",
          "Connect Middleware Concepts"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Middleware Chains: The Backbone of Express Apps",
          "gist": "Explain how middleware chaining enables cross-cutting concerns.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T10-ST05",
        "title": "Error handling patterns",
        "details": "Learn consistent error handling patterns: centralized handlers, operational vs programmer errors, and safe error responses.",
        "masteryCriteria": [
          {
            "criteria": "Can design centralized error handling",
            "mastered": false
          },
          {
            "criteria": "Can classify error types",
            "mastered": false
          },
          {
            "criteria": "Can avoid leaking sensitive details",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement a global error handler",
            "completed": false
          },
          {
            "task": "Normalize API error responses",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "error-handling-patterns",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Node.js Best Practices",
          "Express Error Handling Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Error Handling Patterns for Node.js APIs",
          "gist": "Explain how to handle errors predictably and safely.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T10-ST06",
        "title": "Validation strategies",
        "details": "Understand request validation approaches at boundaries: schema-based validation, runtime checks, and fail-fast principles.",
        "masteryCriteria": [
          {
            "criteria": "Can validate inputs consistently",
            "mastered": false
          },
          {
            "criteria": "Can reject invalid requests early",
            "mastered": false
          },
          {
            "criteria": "Can avoid duplicated validation logic",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add request validation middleware",
            "completed": false
          },
          {
            "task": "Handle validation errors cleanly",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "validation-strategies",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Zod Documentation",
          "Joi Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Validation Strategies for Reliable APIs",
          "gist": "Explain why validation belongs at the API boundary.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T10-ST07",
        "title": "Auth flows (JWT, cookies, refresh)",
        "details": "Understand authentication flows using JWTs and cookies, refresh tokens, token rotation, and session security.",
        "masteryCriteria": [
          {
            "criteria": "Can implement JWT and cookie auth",
            "mastered": false
          },
          {
            "criteria": "Can design refresh flows",
            "mastered": false
          },
          {
            "criteria": "Can mitigate common auth risks",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement login with refresh tokens",
            "completed": false
          },
          {
            "task": "Rotate and revoke tokens",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "auth-flows",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OWASP Authentication Cheat Sheet",
          "Auth0 JWT Guides"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Authentication Flows in Modern APIs",
          "gist": "Compare JWT and cookie-based authentication with refresh flows.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T10-ST08",
        "title": "RBAC",
        "details": "Understand Role-Based Access Control and how to enforce authorization rules at the API layer.",
        "masteryCriteria": [
          {
            "criteria": "Can design RBAC models",
            "mastered": false
          },
          {
            "criteria": "Can enforce authorization consistently",
            "mastered": false
          },
          {
            "criteria": "Can avoid privilege escalation",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement RBAC middleware",
            "completed": false
          },
          {
            "task": "Test role-based access scenarios",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "rbac-implementation",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OWASP Authorization Cheat Sheet",
          "NIST RBAC Model"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "RBAC: Controlling Access in APIs",
          "gist": "Explain how roles map to permissions and API enforcement.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T10-ST09",
        "title": "Background jobs",
        "details": "Understand background job processing for tasks that should not block API responses.",
        "masteryCriteria": [
          {
            "criteria": "Can identify background job use cases",
            "mastered": false
          },
          {
            "criteria": "Can decouple jobs from requests",
            "mastered": false
          },
          {
            "criteria": "Can monitor job execution",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Move heavy tasks to background jobs",
            "completed": false
          },
          {
            "task": "Track job status",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "background-jobs",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "BullMQ Documentation",
          "Agenda Job Scheduler"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Background Jobs: Keeping APIs Fast",
          "gist": "Explain why long-running work doesn't belong in request handlers.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T10-ST10",
        "title": "Queues",
        "details": "Understand message queues for reliable job processing, retries, and scaling workers independently.",
        "masteryCriteria": [
          {
            "criteria": "Can explain queue-based architectures",
            "mastered": false
          },
          {
            "criteria": "Can configure producers and consumers",
            "mastered": false
          },
          {
            "criteria": "Can handle failures",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Set up a queue with workers",
            "completed": false
          },
          {
            "task": "Simulate retries and failures",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "queues",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "RabbitMQ Concepts",
          "BullMQ Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Queues: Decoupling Work in Backend Systems",
          "gist": "Explain how queues enable reliability and scalability.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T10-ST11",
        "title": "Cron jobs",
        "details": "Understand scheduled tasks for periodic work and how to run them safely and reliably.",
        "masteryCriteria": [
          {
            "criteria": "Can schedule recurring jobs",
            "mastered": false
          },
          {
            "criteria": "Can avoid overlapping executions",
            "mastered": false
          },
          {
            "criteria": "Can handle failures",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create scheduled jobs",
            "completed": false
          },
          {
            "task": "Add monitoring and alerts",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "cron-jobs",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Cron Syntax Documentation",
          "node-cron"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Cron Jobs: Scheduling Work Safely",
          "gist": "Explain cron usage patterns and common pitfalls.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T10-ST12",
        "title": "API versioning",
        "details": "Understand strategies for evolving APIs without breaking clients: URL, header, and media-type versioning.",
        "masteryCriteria": [
          {
            "criteria": "Can version APIs intentionally",
            "mastered": false
          },
          {
            "criteria": "Can manage backward compatibility",
            "mastered": false
          },
          {
            "criteria": "Can deprecate endpoints safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add versioning to an API",
            "completed": false
          },
          {
            "task": "Migrate clients between versions",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "api-versioning",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Microsoft REST API Guidelines",
          "Stripe API Versioning"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "API Versioning Without Breaking Clients",
          "gist": "Explain versioning strategies and tradeoffs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T10-ST13",
        "title": "Schema validation",
        "details": "Understand schema validation as a contract enforcement mechanism between clients and servers.",
        "masteryCriteria": [
          {
            "criteria": "Can define schemas for requests and responses",
            "mastered": false
          },
          {
            "criteria": "Can enforce schema validation",
            "mastered": false
          },
          {
            "criteria": "Can keep schemas in sync",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Define request/response schemas",
            "completed": false
          },
          {
            "task": "Validate inputs and outputs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "schema-validation",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OpenAPI Specification",
          "Zod / Joi Schema Validation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Schema Validation: Enforcing API Contracts",
          "gist": "Explain why schemas prevent entire classes of bugs.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T11",
    "title": "Databases & Data Modeling",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic builds strong fundamentals for designing, querying, and maintaining databases that scale safely. Mastery means you can choose the right database type, design schemas intentionally, reason about performance and consistency, and operate databases reliably in production.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P5"
    ],
    "references": [
      "Designing Data-Intensive Applications - Martin Kleppmann",
      "MongoDB Documentation",
      "PostgreSQL Documentation"
    ],
    "subTasks": [
      {
        "id": "T11-ST01",
        "title": "Relational vs NoSQL",
        "details": "Understand the fundamental differences between relational and NoSQL databases: data models, query capabilities, scalability patterns, and consistency tradeoffs.",
        "masteryCriteria": [
          {
            "criteria": "Can explain relational vs NoSQL differences",
            "mastered": false
          },
          {
            "criteria": "Can choose the right database type",
            "mastered": false
          },
          {
            "criteria": "Can justify tradeoffs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Model the same data in SQL and NoSQL",
            "completed": false
          },
          {
            "task": "Compare querying and scaling behavior",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "relational-vs-nosql",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "DDIA - Data Models",
          "MongoDB vs PostgreSQL Comparisons"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Relational vs NoSQL: Choosing the Right Database",
          "gist": "Explain tradeoffs between relational and NoSQL databases with real examples.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T11-ST02",
        "title": "Schema design",
        "details": "Learn how to design schemas that reflect domain models, avoid redundancy, and support future changes.",
        "masteryCriteria": [
          {
            "criteria": "Can design normalized schemas",
            "mastered": false
          },
          {
            "criteria": "Can denormalize intentionally",
            "mastered": false
          },
          {
            "criteria": "Can evolve schemas safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Design schemas for a sample domain",
            "completed": false
          },
          {
            "task": "Refactor a poorly designed schema",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "schema-design",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "DDIA - Schema Design",
          "PostgreSQL Schema Design Docs"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Schema Design: Modeling Data for the Long Term",
          "gist": "Explain schema design principles and common mistakes.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T11-ST03",
        "title": "Indexing strategies",
        "details": "Understand indexes as performance structures. Learn different index types, when to use them, and their write/read tradeoffs.",
        "masteryCriteria": [
          {
            "criteria": "Can explain how indexes work",
            "mastered": false
          },
          {
            "criteria": "Can choose appropriate index types",
            "mastered": false
          },
          {
            "criteria": "Can avoid over-indexing",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add and remove indexes",
            "completed": false
          },
          {
            "task": "Measure query performance changes",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "indexing-strategies",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "PostgreSQL Indexes",
          "MongoDB Indexing Guide"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Indexing Strategies: Making Queries Fast Without Breaking Writes",
          "gist": "Explain index tradeoffs and real-world usage.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T11-ST04",
        "title": "Query optimization",
        "details": "Learn how databases execute queries, how query planners work, and how to optimize slow queries using explain plans.",
        "masteryCriteria": [
          {
            "criteria": "Can read query execution plans",
            "mastered": false
          },
          {
            "criteria": "Can optimize slow queries",
            "mastered": false
          },
          {
            "criteria": "Can avoid anti-patterns",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze slow queries",
            "completed": false
          },
          {
            "task": "Optimize queries using indexes",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "query-optimization",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "PostgreSQL EXPLAIN",
          "MongoDB Query Optimization"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Query Optimization: Understanding What the Database Is Actually Doing",
          "gist": "Explain query planners and optimization techniques.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T11-ST05",
        "title": "Transactions",
        "details": "Understand database transactions, ACID properties, isolation levels, and how transactions protect data integrity.",
        "masteryCriteria": [
          {
            "criteria": "Can explain ACID properties",
            "mastered": false
          },
          {
            "criteria": "Can choose isolation levels",
            "mastered": false
          },
          {
            "criteria": "Can avoid transaction misuse",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write transactional operations",
            "completed": false
          },
          {
            "task": "Simulate transaction conflicts",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "transactions",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "PostgreSQL Transactions",
          "DDIA - Transactions"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Transactions Explained: ACID in Practice",
          "gist": "Explain transactions and isolation levels with real examples.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T11-ST06",
        "title": "Data consistency",
        "details": "Understand consistency models, tradeoffs in distributed systems, and eventual vs strong consistency.",
        "masteryCriteria": [
          {
            "criteria": "Can explain consistency models",
            "mastered": false
          },
          {
            "criteria": "Can reason about stale data",
            "mastered": false
          },
          {
            "criteria": "Can design around consistency tradeoffs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Simulate eventual consistency",
            "completed": false
          },
          {
            "task": "Handle consistency-related edge cases",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "data-consistency",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "DDIA - Consistency",
          "CAP Theorem Explained"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Data Consistency: Why Your Data Isn't Always What You Expect",
          "gist": "Explain consistency models and their implications.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T11-ST07",
        "title": "Pagination strategies",
        "details": "Understand offset vs cursor pagination, performance implications, and correctness issues in large datasets.",
        "masteryCriteria": [
          {
            "criteria": "Can implement pagination safely",
            "mastered": false
          },
          {
            "criteria": "Can choose offset vs cursor",
            "mastered": false
          },
          {
            "criteria": "Can avoid missing or duplicated records",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement cursor-based pagination",
            "completed": false
          },
          {
            "task": "Test pagination edge cases",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "pagination-strategies",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Stripe Pagination Design",
          "MongoDB Pagination Patterns"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Pagination Strategies for Large Datasets",
          "gist": "Explain pagination tradeoffs and best practices.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T11-ST08",
        "title": "Soft deletes",
        "details": "Understand soft deletes as a strategy to retain historical data while hiding records from active queries.",
        "masteryCriteria": [
          {
            "criteria": "Can implement soft deletes",
            "mastered": false
          },
          {
            "criteria": "Can handle filtering correctly",
            "mastered": false
          },
          {
            "criteria": "Can avoid data leakage",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add soft delete support",
            "completed": false
          },
          {
            "task": "Ensure deleted records are excluded",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "soft-deletes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Database Soft Delete Patterns",
          "ORM Soft Delete Implementations"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Soft Deletes: Keeping Data Without Breaking Queries",
          "gist": "Explain when and how to use soft deletes safely.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T11-ST09",
        "title": "Migrations",
        "details": "Learn how to evolve database schemas safely using migrations, versioning, and backward-compatible changes.",
        "masteryCriteria": [
          {
            "criteria": "Can write safe migrations",
            "mastered": false
          },
          {
            "criteria": "Can rollback migrations",
            "mastered": false
          },
          {
            "criteria": "Can avoid downtime",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create schema migrations",
            "completed": false
          },
          {
            "task": "Test rollbacks",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "db-migrations",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Flyway Documentation",
          "Prisma Migrations"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Database Migrations Without Downtime",
          "gist": "Explain safe schema evolution strategies.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T11-ST10",
        "title": "Backups & recovery",
        "details": "Understand backup strategies, recovery procedures, and disaster recovery planning for databases.",
        "masteryCriteria": [
          {
            "criteria": "Can design backup strategies",
            "mastered": false
          },
          {
            "criteria": "Can restore from backups",
            "mastered": false
          },
          {
            "criteria": "Can plan for disaster recovery",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create and restore backups",
            "completed": false
          },
          {
            "task": "Simulate data loss recovery",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "backups-recovery",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "PostgreSQL Backup Docs",
          "MongoDB Backup & Restore"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Backups and Recovery: Preparing for the Worst",
          "gist": "Explain backup strategies and recovery planning.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T12",
    "title": "Performance Engineering",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic builds a systematic approach to performance across frontend, backend, and infrastructure. Mastery means you can set measurable performance goals, identify real bottlenecks, apply the right optimizations, and verify improvements with data rather than assumptions.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P5"
    ],
    "references": [
      "web.dev - Performance",
      "Google Web Vitals",
      "High Performance Browser Networking - Ilya Grigorik"
    ],
    "subTasks": [
      {
        "id": "T12-ST01",
        "title": "Web Vitals (LCP, CLS, INP)",
        "details": "Understand Core Web Vitals as user-centric performance metrics. Learn what LCP, CLS, and INP measure, why they matter, and what typically causes poor scores.",
        "masteryCriteria": [
          {
            "criteria": "Can explain each Core Web Vital",
            "mastered": false
          },
          {
            "criteria": "Can identify causes of poor scores",
            "mastered": false
          },
          {
            "criteria": "Can prioritize fixes based on impact",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Measure Web Vitals for a real page",
            "completed": false
          },
          {
            "task": "Fix at least one metric intentionally",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "web-vitals-analysis",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "web.dev - Core Web Vitals",
          "Google PageSpeed Insights Docs"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Web Vitals Explained: Measuring What Users Actually Feel",
          "gist": "Explain LCP, CLS, and INP with real examples and optimization ideas.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T12-ST02",
        "title": "Bundle size budgets",
        "details": "Learn to set and enforce bundle size budgets to prevent gradual performance regressions as features are added.",
        "masteryCriteria": [
          {
            "criteria": "Can define realistic bundle budgets",
            "mastered": false
          },
          {
            "criteria": "Can enforce budgets in CI",
            "mastered": false
          },
          {
            "criteria": "Can act on budget violations",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Define bundle size limits",
            "completed": false
          },
          {
            "task": "Fail a build on budget breach",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "bundle-size-budgets",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "web.dev - Performance Budgets",
          "Webpack Performance Hints"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Bundle Size Budgets: Preventing Performance Death by a Thousand Cuts",
          "gist": "Explain why budgets matter and how to enforce them.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T12-ST03",
        "title": "Lazy loading strategies",
        "details": "Understand lazy loading for code, images, and data. Learn how to defer non-critical work without hurting UX.",
        "masteryCriteria": [
          {
            "criteria": "Can identify lazy-load candidates",
            "mastered": false
          },
          {
            "criteria": "Can avoid loading waterfalls",
            "mastered": false
          },
          {
            "criteria": "Can measure impact",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Lazy-load routes or components",
            "completed": false
          },
          {
            "task": "Measure initial load improvement",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "lazy-loading-strategies",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Lazy Loading",
          "React Docs - Code Splitting"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Lazy Loading Without Breaking UX",
          "gist": "Explain different lazy loading strategies and tradeoffs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T12-ST04",
        "title": "Image optimization",
        "details": "Learn how image formats, compression, sizing, and delivery affect performance. Understand responsive images and modern formats.",
        "masteryCriteria": [
          {
            "criteria": "Can choose optimal image formats",
            "mastered": false
          },
          {
            "criteria": "Can serve responsive images",
            "mastered": false
          },
          {
            "criteria": "Can reduce image payload significantly",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Optimize images for a page",
            "completed": false
          },
          {
            "task": "Compare before/after performance",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "image-optimization",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "web.dev - Image Optimization",
          "MDN - Responsive Images"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Image Optimization: The Biggest Performance Win You're Probably Missing",
          "gist": "Explain image formats, compression, and responsive delivery.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T12-ST05",
        "title": "CDN basics",
        "details": "Understand Content Delivery Networks as a way to reduce latency and offload traffic. Learn basic CDN concepts and caching behavior.",
        "masteryCriteria": [
          {
            "criteria": "Can explain what a CDN does",
            "mastered": false
          },
          {
            "criteria": "Can configure basic CDN caching",
            "mastered": false
          },
          {
            "criteria": "Can explain cache hit vs miss",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Serve assets through a CDN",
            "completed": false
          },
          {
            "task": "Inspect cache headers",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "cdn-basics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Cloudflare Learning Center",
          "AWS CloudFront Docs"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "CDNs Explained: Faster Content With Fewer Servers",
          "gist": "Explain how CDNs improve performance and scalability.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T12-ST06",
        "title": "Server caching",
        "details": "Understand server-side caching strategies to reduce computation and database load.",
        "masteryCriteria": [
          {
            "criteria": "Can implement server-side caching",
            "mastered": false
          },
          {
            "criteria": "Can set cache TTLs correctly",
            "mastered": false
          },
          {
            "criteria": "Can invalidate caches safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add caching to an API endpoint",
            "completed": false
          },
          {
            "task": "Measure response time improvements",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "server-caching",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Redis Documentation",
          "HTTP Caching RFCs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Server Caching: Making Backends Faster Without Scaling",
          "gist": "Explain server-side caching strategies and tradeoffs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T12-ST07",
        "title": "Client caching",
        "details": "Understand browser caching mechanisms and how to leverage them using HTTP headers.",
        "masteryCriteria": [
          {
            "criteria": "Can configure browser caching",
            "mastered": false
          },
          {
            "criteria": "Can choose correct cache headers",
            "mastered": false
          },
          {
            "criteria": "Can debug stale cache issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Configure client caching headers",
            "completed": false
          },
          {
            "task": "Inspect cache behavior in DevTools",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "client-caching",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - HTTP Caching",
          "web.dev - Cache-Control"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Client Caching: Faster Loads With Smart Headers",
          "gist": "Explain browser caching and cache-control strategies.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T12-ST08",
        "title": "Debouncing & throttling",
        "details": "Understand debouncing and throttling as techniques to control event frequency and improve responsiveness.",
        "masteryCriteria": [
          {
            "criteria": "Can explain debounce vs throttle",
            "mastered": false
          },
          {
            "criteria": "Can apply them correctly",
            "mastered": false
          },
          {
            "criteria": "Can avoid overuse",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Debounce input handlers",
            "completed": false
          },
          {
            "task": "Throttle scroll or resize events",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "debounce-throttle",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN - Throttling",
          "Lodash Debounce/Throttle Docs"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Debouncing vs Throttling: Controlling Expensive Events",
          "gist": "Explain when to debounce and when to throttle.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T12-ST09",
        "title": "Load testing basics",
        "details": "Learn the fundamentals of load testing to understand system behavior under stress.",
        "masteryCriteria": [
          {
            "criteria": "Can design basic load tests",
            "mastered": false
          },
          {
            "criteria": "Can interpret results",
            "mastered": false
          },
          {
            "criteria": "Can identify breaking points",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Run a basic load test",
            "completed": false
          },
          {
            "task": "Analyze response times under load",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "load-testing-basics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "k6 Documentation",
          "Apache JMeter Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Load Testing Basics: Knowing Your System's Limits",
          "gist": "Explain why load testing matters and how to get started.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T12-ST10",
        "title": "Bottleneck identification",
        "details": "Understand how to systematically find performance bottlenecks instead of guessing.",
        "masteryCriteria": [
          {
            "criteria": "Can identify bottlenecks accurately",
            "mastered": false
          },
          {
            "criteria": "Can distinguish symptoms from causes",
            "mastered": false
          },
          {
            "criteria": "Can prioritize fixes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze a slow system",
            "completed": false
          },
          {
            "task": "Document bottleneck findings",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "bottleneck-analysis",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Performance Debugging",
          "Netflix Tech Blog - Performance"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Finding Performance Bottlenecks Without Guessing",
          "gist": "Explain a systematic approach to performance debugging.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T12-ST11",
        "title": "Profiling (frontend & backend)",
        "details": "Learn to profile applications to understand where time and resources are spent.",
        "masteryCriteria": [
          {
            "criteria": "Can profile frontend performance",
            "mastered": false
          },
          {
            "criteria": "Can profile backend execution",
            "mastered": false
          },
          {
            "criteria": "Can interpret profiling data",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Profile a frontend interaction",
            "completed": false
          },
          {
            "task": "Profile backend request handling",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "profiling-tools",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Chrome DevTools Performance Panel",
          "Node.js Profiling Docs"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Profiling Frontend and Backend: Measuring Before Optimizing",
          "gist": "Explain profiling techniques and tools.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T13",
    "title": "Debugging & Observability (Senior+ Skill)",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic focuses on the skills required to understand, debug, and operate systems in production. Mastery means you can investigate unknown failures, reason from signals instead of assumptions, and drive issues to root cause using logs, metrics, traces, and profiling tools.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P5"
    ],
    "references": [
      "Google SRE Book - Monitoring",
      "Observability Engineering - Charity Majors",
      "Chrome DevTools Documentation"
    ],
    "subTasks": [
      {
        "id": "T13-ST01",
        "title": "Chrome DevTools mastery",
        "details": "Gain deep proficiency with Chrome DevTools: Elements, Console, Sources, Network, Performance, Memory, and Application panels. Focus on systematic debugging rather than ad-hoc inspection.",
        "masteryCriteria": [
          {
            "criteria": "Can debug complex frontend issues",
            "mastered": false
          },
          {
            "criteria": "Can trace execution using breakpoints",
            "mastered": false
          },
          {
            "criteria": "Can inspect runtime state accurately",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Debug a complex UI bug using DevTools",
            "completed": false
          },
          {
            "task": "Trace execution across async boundaries",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "chrome-devtools-mastery",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Chrome DevTools Docs",
          "web.dev - Debugging"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Chrome DevTools: The Most Important Debugging Skill for Frontend Engineers",
          "gist": "Explain how to use DevTools effectively to debug real-world frontend issues.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T13-ST02",
        "title": "Network debugging",
        "details": "Understand how to debug network issues by inspecting requests, responses, timing, headers, payloads, and failures using browser and server-side tools.",
        "masteryCriteria": [
          {
            "criteria": "Can diagnose network failures",
            "mastered": false
          },
          {
            "criteria": "Can analyze request timing",
            "mastered": false
          },
          {
            "criteria": "Can identify client vs server issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Debug failing API calls",
            "completed": false
          },
          {
            "task": "Analyze slow network requests",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "network-debugging",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Chrome DevTools - Network Panel",
          "MDN - Network Debugging"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Network Debugging: Finding the Truth Between Client and Server",
          "gist": "Explain systematic network debugging using real examples.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T13-ST03",
        "title": "Memory profiling",
        "details": "Learn how to detect memory leaks and excessive memory usage in frontend and backend systems using heap snapshots and allocation timelines.",
        "masteryCriteria": [
          {
            "criteria": "Can identify memory leaks",
            "mastered": false
          },
          {
            "criteria": "Can interpret heap snapshots",
            "mastered": false
          },
          {
            "criteria": "Can reduce memory footprint",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Capture and analyze heap snapshots",
            "completed": false
          },
          {
            "task": "Fix a memory leak",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "memory-profiling",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Chrome DevTools - Memory Panel",
          "Node.js Memory Profiling"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Memory Profiling: Finding Leaks Before They Crash Your App",
          "gist": "Explain memory profiling techniques and leak detection.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T13-ST04",
        "title": "Flame charts",
        "details": "Understand flame charts as a visualization of execution time and call stacks to identify performance hotspots.",
        "masteryCriteria": [
          {
            "criteria": "Can read flame charts",
            "mastered": false
          },
          {
            "criteria": "Can identify hot paths",
            "mastered": false
          },
          {
            "criteria": "Can prioritize optimization targets",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze flame charts",
            "completed": false
          },
          {
            "task": "Optimize identified hotspots",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "flame-charts",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Chrome DevTools - Performance Panel",
          "Brendan Gregg - Flame Graphs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Flame Charts Explained: Seeing Where Time Really Goes",
          "gist": "Explain how to read flame charts and act on them.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T13-ST05",
        "title": "Logging strategy",
        "details": "Learn how to design a logging strategy that provides useful context without overwhelming systems or teams.",
        "masteryCriteria": [
          {
            "criteria": "Can define logging goals",
            "mastered": false
          },
          {
            "criteria": "Can structure logs",
            "mastered": false
          },
          {
            "criteria": "Can avoid noisy logging",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Design a logging strategy",
            "completed": false
          },
          {
            "task": "Refactor noisy logs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "logging-strategy",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Logging",
          "OWASP Logging Guidelines"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Logging Strategy: Logs That Actually Help in Production",
          "gist": "Explain how to design logs that support debugging and analysis.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T13-ST06",
        "title": "Log levels",
        "details": "Understand log levels, their purpose, and how to use them consistently to control verbosity and signal importance.",
        "masteryCriteria": [
          {
            "criteria": "Can choose correct log levels",
            "mastered": false
          },
          {
            "criteria": "Can avoid misuse of levels",
            "mastered": false
          },
          {
            "criteria": "Can configure environments differently",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Refactor logs to correct levels",
            "completed": false
          },
          {
            "task": "Configure log level filtering",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "log-levels",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Log4j Logging Levels",
          "Google SRE - Logging Levels"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Log Levels Explained: Signal vs Noise",
          "gist": "Explain how log levels improve observability and reduce noise.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T13-ST07",
        "title": "Metrics vs logs vs traces",
        "details": "Understand the three pillars of observability, what questions each answers, and how they complement each other.",
        "masteryCriteria": [
          {
            "criteria": "Can explain metrics, logs, and traces",
            "mastered": false
          },
          {
            "criteria": "Can choose the right signal",
            "mastered": false
          },
          {
            "criteria": "Can correlate signals",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Map incidents to observability signals",
            "completed": false
          },
          {
            "task": "Correlate metrics with logs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "metrics-logs-traces",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OpenTelemetry Documentation",
          "Observability Engineering"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Metrics vs Logs vs Traces: Choosing the Right Signal",
          "gist": "Explain the observability pillars and their use cases.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T13-ST08",
        "title": "Error tracking",
        "details": "Learn how to track, aggregate, and analyze runtime errors using error tracking systems.",
        "masteryCriteria": [
          {
            "criteria": "Can configure error tracking",
            "mastered": false
          },
          {
            "criteria": "Can triage errors effectively",
            "mastered": false
          },
          {
            "criteria": "Can prioritize fixes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Integrate error tracking",
            "completed": false
          },
          {
            "task": "Analyze error trends",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "error-tracking",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Sentry Documentation",
          "Rollbar Documentation"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Error Tracking: Seeing Failures Before Users Report Them",
          "gist": "Explain how error tracking improves reliability.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T13-ST09",
        "title": "Alerting",
        "details": "Understand alerting as a signal-driven process that notifies teams of actionable issues without causing alert fatigue.",
        "masteryCriteria": [
          {
            "criteria": "Can design actionable alerts",
            "mastered": false
          },
          {
            "criteria": "Can avoid alert fatigue",
            "mastered": false
          },
          {
            "criteria": "Can tune alert thresholds",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create actionable alerts",
            "completed": false
          },
          {
            "task": "Refine alert rules",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "alerting",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Alerting",
          "PagerDuty Alerting Guides"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Alerting Without Alert Fatigue",
          "gist": "Explain how to design alerts that teams respond to.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T13-ST10",
        "title": "Root cause analysis",
        "details": "Learn how to conduct root cause analysis to understand why incidents happened and how to prevent recurrence.",
        "masteryCriteria": [
          {
            "criteria": "Can perform structured RCA",
            "mastered": false
          },
          {
            "criteria": "Can identify systemic issues",
            "mastered": false
          },
          {
            "criteria": "Can propose preventive actions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Conduct a mock incident RCA",
            "completed": false
          },
          {
            "task": "Document findings and actions",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "root-cause-analysis",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Postmortems",
          "Incident Management Best Practices"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Root Cause Analysis: Fixing Problems at the Source",
          "gist": "Explain how RCA leads to long-term system reliability.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T14",
    "title": "Security (Baseline Knowledge)",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "medium",
    "details": "This topic establishes essential security knowledge required for all web developers. Mastery means you can recognize common attack vectors, apply preventive controls by default, and avoid introducing basic security flaws into applications.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P5"
    ],
    "references": [
      "OWASP Top 10",
      "OWASP WebGoat",
      "Mozilla Web Security Guidelines"
    ],
    "subTasks": [
      {
        "id": "T14-ST01",
        "title": "OWASP Top 10",
        "details": "Understand the OWASP Top 10 list as a classification of the most critical web application security risks and why they matter in real systems.",
        "masteryCriteria": [
          {
            "criteria": "Can explain each OWASP Top 10 category",
            "mastered": false
          },
          {
            "criteria": "Can identify risks in real applications",
            "mastered": false
          },
          {
            "criteria": "Can map mitigations to risks",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Review OWASP Top 10 cases",
            "completed": false
          },
          {
            "task": "Identify OWASP risks in a sample app",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "owasp-top-10",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OWASP Top 10 Official Site",
          "OWASP WebGoat"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "OWASP Top 10: Security Risks Every Web Developer Must Know",
          "gist": "Explain the OWASP Top 10 with practical examples and mitigations.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T14-ST02",
        "title": "Input validation",
        "details": "Understand input validation as a primary defense against injection attacks and malformed data entering systems.",
        "masteryCriteria": [
          {
            "criteria": "Can validate inputs at boundaries",
            "mastered": false
          },
          {
            "criteria": "Can prevent injection vulnerabilities",
            "mastered": false
          },
          {
            "criteria": "Can avoid trusting client input",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement schema-based input validation",
            "completed": false
          },
          {
            "task": "Test invalid and malicious inputs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "input-validation-security",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OWASP Input Validation Cheat Sheet",
          "OWASP Injection Prevention"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Input Validation: Your First Line of Defense",
          "gist": "Explain why input validation prevents entire classes of attacks.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T14-ST03",
        "title": "Auth vulnerabilities",
        "details": "Understand common authentication vulnerabilities such as broken auth flows, weak passwords, and improper session handling.",
        "masteryCriteria": [
          {
            "criteria": "Can identify auth vulnerabilities",
            "mastered": false
          },
          {
            "criteria": "Can design secure auth flows",
            "mastered": false
          },
          {
            "criteria": "Can prevent common auth attacks",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Audit an auth implementation",
            "completed": false
          },
          {
            "task": "Fix insecure auth patterns",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "auth-vulnerabilities",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OWASP Authentication Cheat Sheet",
          "OWASP Broken Authentication"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Common Authentication Vulnerabilities and How to Avoid Them",
          "gist": "Explain real-world auth vulnerabilities and mitigations.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T14-ST04",
        "title": "Token storage risks",
        "details": "Understand risks associated with storing tokens in browsers, including XSS exposure and persistence tradeoffs.",
        "masteryCriteria": [
          {
            "criteria": "Can explain token storage risks",
            "mastered": false
          },
          {
            "criteria": "Can choose safer storage mechanisms",
            "mastered": false
          },
          {
            "criteria": "Can mitigate token leakage",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Compare token storage strategies",
            "completed": false
          },
          {
            "task": "Audit frontend token usage",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "token-storage-risks",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OWASP Token Storage Guidance",
          "MDN - Web Storage Security"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Token Storage Risks: Where Your Auth Tokens Really Belong",
          "gist": "Explain storage tradeoffs and security implications.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T14-ST05",
        "title": "Secure headers",
        "details": "Understand security-related HTTP headers that protect applications against common attacks.",
        "masteryCriteria": [
          {
            "criteria": "Can explain key security headers",
            "mastered": false
          },
          {
            "criteria": "Can configure headers correctly",
            "mastered": false
          },
          {
            "criteria": "Can avoid breaking functionality",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add security headers to an app",
            "completed": false
          },
          {
            "task": "Verify headers using security tools",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "secure-headers",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OWASP Secure Headers Project",
          "Mozilla Observatory"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Secure Headers: Small Changes, Big Security Gains",
          "gist": "Explain how security headers reduce attack surface.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T14-ST06",
        "title": "Secrets management",
        "details": "Understand how to store, access, and rotate secrets securely without exposing them in code or builds.",
        "masteryCriteria": [
          {
            "criteria": "Can manage secrets safely",
            "mastered": false
          },
          {
            "criteria": "Can avoid committing secrets",
            "mastered": false
          },
          {
            "criteria": "Can rotate secrets without downtime",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Move secrets out of code",
            "completed": false
          },
          {
            "task": "Rotate a compromised secret",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "secrets-management",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "12-Factor App - Config",
          "AWS Secrets Manager Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Secrets Management: Keeping Secrets Out of Your Codebase",
          "gist": "Explain best practices for secret storage and rotation.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T14-ST07",
        "title": "Rate limiting attacks",
        "details": "Understand how attackers abuse APIs via brute force, scraping, or denial-of-service attempts and how rate limiting mitigates these risks.",
        "masteryCriteria": [
          {
            "criteria": "Can explain rate limiting attack scenarios",
            "mastered": false
          },
          {
            "criteria": "Can implement defensive rate limits",
            "mastered": false
          },
          {
            "criteria": "Can tune limits safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Simulate brute-force attempts",
            "completed": false
          },
          {
            "task": "Add rate limiting defenses",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "rate-limiting-attacks",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OWASP API Security Top 10",
          "Cloudflare Rate Limiting Guides"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Rate Limiting Attacks: Defending APIs From Abuse",
          "gist": "Explain common attack patterns and defensive strategies.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T14-ST08",
        "title": "Dependency vulnerabilities",
        "details": "Understand risks introduced by third-party dependencies and how to detect and mitigate vulnerable packages.",
        "masteryCriteria": [
          {
            "criteria": "Can identify vulnerable dependencies",
            "mastered": false
          },
          {
            "criteria": "Can assess risk impact",
            "mastered": false
          },
          {
            "criteria": "Can update dependencies safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Scan dependencies for vulnerabilities",
            "completed": false
          },
          {
            "task": "Patch or replace vulnerable packages",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "dependency-vulnerabilities",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "npm audit",
          "Snyk Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Dependency Vulnerabilities: Hidden Risks in Your Stack",
          "gist": "Explain why dependency security matters and how to manage it.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T15",
    "title": "Testing Strategy",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "medium",
    "details": "This topic establishes a disciplined testing approach to ensure correctness, confidence, and long-term maintainability. Mastery means you can choose the right test type, structure tests for clarity and speed, manage test data reliably, and keep the test suite trustworthy as systems evolve.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P5"
    ],
    "references": [
      "Testing JavaScript - Kent C. Dodds",
      "Google Testing Blog",
      "Martin Fowler - Testing"
    ],
    "subTasks": [
      {
        "id": "T15-ST01",
        "title": "Testing pyramid",
        "details": "Understand the testing pyramid as a guideline for balancing unit, integration, and end-to-end tests to achieve fast feedback and confidence.",
        "masteryCriteria": [
          {
            "criteria": "Can explain the testing pyramid",
            "mastered": false
          },
          {
            "criteria": "Can justify test distribution",
            "mastered": false
          },
          {
            "criteria": "Can avoid over-reliance on E2E tests",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Map existing tests to the pyramid",
            "completed": false
          },
          {
            "task": "Rebalance a skewed test suite",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "testing-pyramid",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Martin Fowler - Testing Pyramid",
          "Kent C. Dodds - Testing Trophy"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "The Testing Pyramid: Building Confidence Without Slowing Teams Down",
          "gist": "Explain how the testing pyramid guides effective test strategy.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T15-ST02",
        "title": "Unit tests",
        "details": "Learn how to write fast, isolated unit tests that verify small pieces of logic deterministically.",
        "masteryCriteria": [
          {
            "criteria": "Can write isolated unit tests",
            "mastered": false
          },
          {
            "criteria": "Can test pure logic",
            "mastered": false
          },
          {
            "criteria": "Can avoid brittle tests",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write unit tests for business logic",
            "completed": false
          },
          {
            "task": "Refactor code for testability",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "unit-tests",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Jest Documentation",
          "Vitest Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Unit Testing: Fast Feedback for Core Logic",
          "gist": "Explain what makes unit tests valuable and reliable.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T15-ST03",
        "title": "Integration tests",
        "details": "Understand integration tests that verify interactions between multiple components such as APIs, databases, or services.",
        "masteryCriteria": [
          {
            "criteria": "Can design meaningful integration tests",
            "mastered": false
          },
          {
            "criteria": "Can control test environments",
            "mastered": false
          },
          {
            "criteria": "Can detect integration failures",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write integration tests for APIs",
            "completed": false
          },
          {
            "task": "Test database interactions",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "integration-tests",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Supertest Documentation",
          "Testcontainers Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Integration Testing: Verifying Systems Work Together",
          "gist": "Explain why integration tests catch bugs unit tests miss.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T15-ST04",
        "title": "E2E tests",
        "details": "Learn end-to-end testing to validate user flows across the full system stack.",
        "masteryCriteria": [
          {
            "criteria": "Can design stable E2E tests",
            "mastered": false
          },
          {
            "criteria": "Can avoid flakiness",
            "mastered": false
          },
          {
            "criteria": "Can prioritize critical user journeys",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write E2E tests for core flows",
            "completed": false
          },
          {
            "task": "Stabilize flaky E2E tests",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "e2e-tests",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Playwright Documentation",
          "Cypress Documentation"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "E2E Testing: Confidence in Real User Flows",
          "gist": "Explain when E2E tests are necessary and how to keep them reliable.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T15-ST05",
        "title": "Mocking strategies",
        "details": "Understand how and when to mock dependencies, balancing isolation with realism.",
        "masteryCriteria": [
          {
            "criteria": "Can mock external dependencies",
            "mastered": false
          },
          {
            "criteria": "Can avoid over-mocking",
            "mastered": false
          },
          {
            "criteria": "Can choose appropriate mock levels",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Mock APIs and services",
            "completed": false
          },
          {
            "task": "Refactor tests to reduce mocks",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "mocking-strategies",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MSW Documentation",
          "Jest Mocking Guide"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Mocking Strategies: Isolation Without Losing Trust",
          "gist": "Explain tradeoffs between mocking and real integrations.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T15-ST06",
        "title": "Contract tests",
        "details": "Understand contract testing to ensure compatibility between services without requiring full end-to-end tests.",
        "masteryCriteria": [
          {
            "criteria": "Can explain contract testing",
            "mastered": false
          },
          {
            "criteria": "Can define service contracts",
            "mastered": false
          },
          {
            "criteria": "Can detect breaking changes early",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write consumer-driven contract tests",
            "completed": false
          },
          {
            "task": "Validate provider contracts",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "contract-tests",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Pact Documentation",
          "Microservices Testing Guides"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Contract Testing: Keeping Services in Sync",
          "gist": "Explain how contract tests prevent integration surprises.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T15-ST07",
        "title": "Test data management",
        "details": "Learn strategies for managing test data to ensure repeatability, isolation, and reliability across test runs.",
        "masteryCriteria": [
          {
            "criteria": "Can create deterministic test data",
            "mastered": false
          },
          {
            "criteria": "Can reset state between tests",
            "mastered": false
          },
          {
            "criteria": "Can avoid data coupling",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Seed test databases",
            "completed": false
          },
          {
            "task": "Isolate test environments",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "test-data-management",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Testcontainers Docs",
          "Database Seeding Patterns"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Test Data Management: Making Tests Repeatable and Reliable",
          "gist": "Explain how poor test data leads to flaky tests.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T15-ST08",
        "title": "Flaky test handling",
        "details": "Understand why tests become flaky and how to detect, diagnose, and eliminate flakiness.",
        "masteryCriteria": [
          {
            "criteria": "Can identify flaky tests",
            "mastered": false
          },
          {
            "criteria": "Can fix timing-related issues",
            "mastered": false
          },
          {
            "criteria": "Can enforce test reliability",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Detect flaky tests",
            "completed": false
          },
          {
            "task": "Stabilize timing-sensitive tests",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "flaky-test-handling",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google Testing Blog - Flaky Tests",
          "Playwright Best Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Flaky Tests: Why They Happen and How to Kill Them",
          "gist": "Explain root causes of flaky tests and prevention strategies.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T15-ST09",
        "title": "Performance testing basics",
        "details": "Learn the basics of performance testing to validate system behavior under load and stress.",
        "masteryCriteria": [
          {
            "criteria": "Can design basic performance tests",
            "mastered": false
          },
          {
            "criteria": "Can interpret performance metrics",
            "mastered": false
          },
          {
            "criteria": "Can identify performance regressions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Run basic performance tests",
            "completed": false
          },
          {
            "task": "Analyze throughput and latency",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "performance-testing-basics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "k6 Documentation",
          "Apache JMeter Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Performance Testing Basics: Catching Slowdowns Early",
          "gist": "Explain why performance tests complement functional tests.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T16",
    "title": "CI/CD & DevOps",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "medium",
    "details": "This topic covers the practices that allow teams to ship changes safely, repeatedly, and confidently. Mastery means you can design reliable pipelines, protect environments, roll out changes incrementally, and recover quickly when things go wrong.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P5"
    ],
    "references": [
      "Google SRE Book - Release Engineering",
      "GitHub Actions Documentation",
      "Atlassian DevOps Guides"
    ],
    "subTasks": [
      {
        "id": "T16-ST01",
        "title": "Git workflows",
        "details": "Understand common Git workflows (feature branches, trunk-based development) and how they impact collaboration, release cadence, and conflict resolution.",
        "masteryCriteria": [
          {
            "criteria": "Can explain common Git workflows",
            "mastered": false
          },
          {
            "criteria": "Can choose an appropriate workflow",
            "mastered": false
          },
          {
            "criteria": "Can resolve merge conflicts confidently",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Apply a Git workflow in a team repo",
            "completed": false
          },
          {
            "task": "Resolve complex merge conflicts",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "git-workflows",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Atlassian Git Workflows",
          "Git Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Git Workflows: Organizing Collaboration Without Chaos",
          "gist": "Explain popular Git workflows and when to use each.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T16-ST02",
        "title": "Code reviews",
        "details": "Learn how code reviews improve code quality, knowledge sharing, and risk reduction when done effectively.",
        "masteryCriteria": [
          {
            "criteria": "Can conduct effective code reviews",
            "mastered": false
          },
          {
            "criteria": "Can give constructive feedback",
            "mastered": false
          },
          {
            "criteria": "Can identify risky changes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Review pull requests",
            "completed": false
          },
          {
            "task": "Incorporate review feedback",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "code-reviews",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google Engineering Practices - Code Reviews",
          "GitHub Pull Request Reviews"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Code Reviews: Raising Quality Without Slowing Teams",
          "gist": "Explain best practices for effective code reviews.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T16-ST03",
        "title": "Automated pipelines",
        "details": "Understand automated pipelines that run tests, checks, and deployments consistently on every change.",
        "masteryCriteria": [
          {
            "criteria": "Can design automated pipelines",
            "mastered": false
          },
          {
            "criteria": "Can fail builds intentionally",
            "mastered": false
          },
          {
            "criteria": "Can ensure repeatability",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create a CI pipeline",
            "completed": false
          },
          {
            "task": "Add automated checks",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "automated-pipelines",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "GitHub Actions Docs",
          "GitLab CI Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Automated Pipelines: Making Releases Boring and Safe",
          "gist": "Explain why automation is critical to reliable delivery.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T16-ST04",
        "title": "Build pipelines",
        "details": "Understand build pipelines as a subset of CI that compile, bundle, and package applications consistently across environments.",
        "masteryCriteria": [
          {
            "criteria": "Can design build pipelines",
            "mastered": false
          },
          {
            "criteria": "Can manage build artifacts",
            "mastered": false
          },
          {
            "criteria": "Can debug build failures",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Set up a build pipeline",
            "completed": false
          },
          {
            "task": "Cache dependencies and builds",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "build-pipelines",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "CI/CD Build Pipelines Guides",
          "Docker Build Concepts"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Build Pipelines: Turning Source Code Into Deployable Artifacts",
          "gist": "Explain build stages and artifact management.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T16-ST05",
        "title": "Environment separation",
        "details": "Learn how to separate environments (dev, staging, production) to reduce risk and validate changes safely.",
        "masteryCriteria": [
          {
            "criteria": "Can design environment separation",
            "mastered": false
          },
          {
            "criteria": "Can manage environment-specific configs",
            "mastered": false
          },
          {
            "criteria": "Can prevent cross-environment leaks",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Configure multiple environments",
            "completed": false
          },
          {
            "task": "Deploy changes progressively",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "environment-separation",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "12-Factor App - Environments",
          "AWS Environment Strategies"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Environment Separation: Reducing Risk Before Production",
          "gist": "Explain why multiple environments are essential.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T16-ST06",
        "title": "Secrets in CI",
        "details": "Understand how to manage secrets securely in CI/CD pipelines without exposing them in logs or code.",
        "masteryCriteria": [
          {
            "criteria": "Can store secrets securely in CI",
            "mastered": false
          },
          {
            "criteria": "Can prevent secret leakage",
            "mastered": false
          },
          {
            "criteria": "Can rotate secrets",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Configure CI secrets",
            "completed": false
          },
          {
            "task": "Audit pipeline logs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "secrets-in-ci",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "GitHub Actions Secrets",
          "GitLab CI Secrets"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Secrets in CI/CD: Keeping Credentials Out of Logs",
          "gist": "Explain best practices for managing secrets in pipelines.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T16-ST07",
        "title": "Rollbacks",
        "details": "Learn rollback strategies to quickly recover from faulty deployments.",
        "masteryCriteria": [
          {
            "criteria": "Can implement rollback mechanisms",
            "mastered": false
          },
          {
            "criteria": "Can minimize downtime",
            "mastered": false
          },
          {
            "criteria": "Can validate rollback safety",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement rollback strategy",
            "completed": false
          },
          {
            "task": "Simulate failed deployments",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "rollbacks",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Rollbacks",
          "Deployment Strategies Docs"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Rollbacks: Recovering Fast When Deployments Go Wrong",
          "gist": "Explain rollback strategies and tradeoffs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T16-ST08",
        "title": "Feature flags",
        "details": "Understand feature flags as a mechanism to decouple deployment from release and control exposure.",
        "masteryCriteria": [
          {
            "criteria": "Can implement feature flags",
            "mastered": false
          },
          {
            "criteria": "Can manage flag lifecycle",
            "mastered": false
          },
          {
            "criteria": "Can avoid flag debt",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add feature flags",
            "completed": false
          },
          {
            "task": "Gradually enable features",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "feature-flags",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "LaunchDarkly Docs",
          "Martin Fowler - Feature Toggles"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Feature Flags: Shipping Code Without Shipping Risk",
          "gist": "Explain how feature flags improve release safety.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T16-ST09",
        "title": "Canary releases",
        "details": "Learn canary release strategies to expose changes gradually and detect issues early.",
        "masteryCriteria": [
          {
            "criteria": "Can design canary releases",
            "mastered": false
          },
          {
            "criteria": "Can monitor canary health",
            "mastered": false
          },
          {
            "criteria": "Can roll back safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement a canary deployment",
            "completed": false
          },
          {
            "task": "Analyze canary metrics",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "canary-releases",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Canarying Releases",
          "Kubernetes Canary Deployments"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Canary Releases: Reducing Deployment Risk With Gradual Rollouts",
          "gist": "Explain canary release mechanics and benefits.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T17",
    "title": "Cloud & Infrastructure (AWS-centric)",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic builds foundational cloud and infrastructure knowledge with an AWS focus. Mastery means you can reason about how traffic flows, choose appropriate compute and storage options, secure access, observe systems in production, control costs, and scale systems intentionally.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P5"
    ],
    "references": [
      "AWS Well-Architected Framework",
      "AWS Documentation",
      "Google SRE Book - Infrastructure"
    ],
    "subTasks": [
      {
        "id": "T17-ST01",
        "title": "DNS basics",
        "details": "Understand DNS as the system that maps domain names to IP addresses, including records, resolution flow, and TTL behavior.",
        "masteryCriteria": [
          {
            "criteria": "Can explain DNS resolution",
            "mastered": false
          },
          {
            "criteria": "Can configure basic DNS records",
            "mastered": false
          },
          {
            "criteria": "Can diagnose common DNS issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Configure DNS records for a domain",
            "completed": false
          },
          {
            "task": "Trace DNS resolution for a request",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "dns-basics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS Route 53 Documentation",
          "Cloudflare DNS Learning Center"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "DNS Basics: How Traffic Finds Your Application",
          "gist": "Explain DNS resolution, records, and why DNS issues are often hard to debug.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T17-ST02",
        "title": "Load balancers",
        "details": "Understand load balancers as traffic distributors that improve availability, scalability, and fault tolerance.",
        "masteryCriteria": [
          {
            "criteria": "Can explain load balancing concepts",
            "mastered": false
          },
          {
            "criteria": "Can configure basic load balancers",
            "mastered": false
          },
          {
            "criteria": "Can explain health checks",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Deploy a load balancer",
            "completed": false
          },
          {
            "task": "Configure health checks",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "load-balancers",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS Elastic Load Balancing Docs",
          "NGINX Load Balancing Concepts"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Load Balancers: Distributing Traffic Safely",
          "gist": "Explain how load balancers improve reliability and scalability.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T17-ST03",
        "title": "Compute options (VM, container, serverless)",
        "details": "Understand different compute models\u2014virtual machines, containers, and serverless\u2014and when to choose each.",
        "masteryCriteria": [
          {
            "criteria": "Can compare compute models",
            "mastered": false
          },
          {
            "criteria": "Can choose appropriate compute",
            "mastered": false
          },
          {
            "criteria": "Can explain tradeoffs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Deploy the same app using different compute models",
            "completed": false
          },
          {
            "task": "Compare operational overhead",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "compute-options",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS EC2 Docs",
          "AWS ECS / EKS Docs",
          "AWS Lambda Docs"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "VMs vs Containers vs Serverless: Choosing Compute Wisely",
          "gist": "Compare compute models and real-world tradeoffs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T17-ST04",
        "title": "Storage types",
        "details": "Understand different storage options (object, block, file) and their performance, durability, and cost characteristics.",
        "masteryCriteria": [
          {
            "criteria": "Can explain storage types",
            "mastered": false
          },
          {
            "criteria": "Can choose appropriate storage",
            "mastered": false
          },
          {
            "criteria": "Can optimize for cost and performance",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Store data using different storage types",
            "completed": false
          },
          {
            "task": "Compare access patterns",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "storage-types",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS S3 Documentation",
          "AWS EBS and EFS Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Cloud Storage Types Explained: Object, Block, and File",
          "gist": "Explain how different storage models impact application design.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T17-ST05",
        "title": "Networking basics (VPC)",
        "details": "Understand cloud networking fundamentals including VPCs, subnets, routing, and security boundaries.",
        "masteryCriteria": [
          {
            "criteria": "Can explain VPC architecture",
            "mastered": false
          },
          {
            "criteria": "Can design basic network layouts",
            "mastered": false
          },
          {
            "criteria": "Can troubleshoot connectivity issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create a VPC with subnets",
            "completed": false
          },
          {
            "task": "Configure routing and security groups",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "vpc-basics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS VPC Documentation",
          "AWS Networking Fundamentals"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Cloud Networking Basics: Understanding VPCs",
          "gist": "Explain how VPCs isolate and secure cloud resources.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T17-ST06",
        "title": "IAM basics",
        "details": "Understand Identity and Access Management as the system that controls who can access what in the cloud.",
        "masteryCriteria": [
          {
            "criteria": "Can explain IAM concepts",
            "mastered": false
          },
          {
            "criteria": "Can create least-privilege policies",
            "mastered": false
          },
          {
            "criteria": "Can avoid common IAM mistakes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create IAM users and roles",
            "completed": false
          },
          {
            "task": "Apply least-privilege policies",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "iam-basics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS IAM Documentation",
          "AWS IAM Best Practices"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "IAM Basics: Securing Access in the Cloud",
          "gist": "Explain IAM concepts and least-privilege access.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T17-ST07",
        "title": "Logging & monitoring",
        "details": "Understand how to collect logs and metrics from cloud resources to observe system health and behavior.",
        "masteryCriteria": [
          {
            "criteria": "Can configure logging",
            "mastered": false
          },
          {
            "criteria": "Can set up monitoring dashboards",
            "mastered": false
          },
          {
            "criteria": "Can detect abnormal behavior",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Enable logging for services",
            "completed": false
          },
          {
            "task": "Create basic monitoring dashboards",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "cloud-logging-monitoring",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS CloudWatch Documentation",
          "AWS X-Ray Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Logging and Monitoring in the Cloud",
          "gist": "Explain how observability applies to cloud infrastructure.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T17-ST08",
        "title": "Cost optimization",
        "details": "Learn how cloud costs accumulate and how to control them using monitoring, right-sizing, and pricing models.",
        "masteryCriteria": [
          {
            "criteria": "Can explain cloud pricing basics",
            "mastered": false
          },
          {
            "criteria": "Can identify cost drivers",
            "mastered": false
          },
          {
            "criteria": "Can optimize costs intentionally",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze cloud cost reports",
            "completed": false
          },
          {
            "task": "Reduce costs without reducing performance",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "cost-optimization",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS Cost Explorer Docs",
          "AWS Well-Architected Cost Pillar"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Cloud Cost Optimization: Avoiding Surprise Bills",
          "gist": "Explain common cost pitfalls and optimization strategies.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T17-ST09",
        "title": "Scaling strategies",
        "details": "Understand scaling strategies including vertical vs horizontal scaling and auto-scaling in cloud environments.",
        "masteryCriteria": [
          {
            "criteria": "Can explain scaling approaches",
            "mastered": false
          },
          {
            "criteria": "Can configure auto-scaling",
            "mastered": false
          },
          {
            "criteria": "Can handle scaling bottlenecks",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Configure auto-scaling",
            "completed": false
          },
          {
            "task": "Test system behavior under load",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "scaling-strategies",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS Auto Scaling Docs",
          "High Scalability Blog"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Scaling Strategies in the Cloud",
          "gist": "Explain how systems scale and where scaling fails.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T18",
    "title": "Architecture & System Design",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic focuses on designing systems that are maintainable, scalable, and resilient over time. Mastery means you can choose appropriate architectural styles, reason about tradeoffs, anticipate failure modes, communicate designs clearly, and evolve systems safely as requirements change.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P6"
    ],
    "references": [
      "Designing Data-Intensive Applications - Martin Kleppmann",
      "Building Evolutionary Architectures - Ford et al.",
      "AWS Architecture Center"
    ],
    "subTasks": [
      {
        "id": "T18-ST01",
        "title": "Monolith vs microservices",
        "details": "Understand monolithic and microservices architectures, including their strengths, weaknesses, and organizational impact.",
        "masteryCriteria": [
          {
            "criteria": "Can explain monolith and microservices differences",
            "mastered": false
          },
          {
            "criteria": "Can choose an appropriate architecture",
            "mastered": false
          },
          {
            "criteria": "Can explain operational tradeoffs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze an existing system architecture",
            "completed": false
          },
          {
            "task": "Justify monolith or microservices choice",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "monolith-vs-microservices",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Martin Fowler - Microservices",
          "AWS Microservices Whitepaper"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Monolith vs Microservices: Choosing Architecture Without Hype",
          "gist": "Explain when monoliths or microservices make sense in real systems.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T18-ST02",
        "title": "Modular monoliths",
        "details": "Learn how modular monoliths structure applications internally to gain many benefits of microservices without distributed complexity.",
        "masteryCriteria": [
          {
            "criteria": "Can explain modular monolith concepts",
            "mastered": false
          },
          {
            "criteria": "Can design clear module boundaries",
            "mastered": false
          },
          {
            "criteria": "Can prevent tight coupling",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Refactor a monolith into modules",
            "completed": false
          },
          {
            "task": "Enforce module boundaries",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "modular-monolith",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Martin Fowler - Modular Monolith",
          "Domain-Driven Design Concepts"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Modular Monoliths: The Practical Middle Ground",
          "gist": "Explain why modular monoliths are often the right starting point.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T18-ST03",
        "title": "Event-driven systems",
        "details": "Understand event-driven architectures, asynchronous communication, and decoupling using events.",
        "masteryCriteria": [
          {
            "criteria": "Can explain event-driven architecture",
            "mastered": false
          },
          {
            "criteria": "Can design event flows",
            "mastered": false
          },
          {
            "criteria": "Can handle eventual consistency",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Design an event-driven workflow",
            "completed": false
          },
          {
            "task": "Handle event retries and failures",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "event-driven-systems",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS Event-Driven Architecture",
          "Apache Kafka Documentation"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Event-Driven Systems: Decoupling With Events",
          "gist": "Explain event-driven design and when it helps scalability.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T18-ST04",
        "title": "API gateways",
        "details": "Understand API gateways as a layer for routing, authentication, rate limiting, and protocol translation.",
        "masteryCriteria": [
          {
            "criteria": "Can explain API gateway responsibilities",
            "mastered": false
          },
          {
            "criteria": "Can decide when a gateway is needed",
            "mastered": false
          },
          {
            "criteria": "Can avoid gateway overuse",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Design an API gateway setup",
            "completed": false
          },
          {
            "task": "Route traffic through a gateway",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "api-gateways",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS API Gateway Docs",
          "NGINX API Gateway Concepts"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "API Gateways: Power and Pitfalls",
          "gist": "Explain what API gateways do and common misuse patterns.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T18-ST05",
        "title": "Caching layers",
        "details": "Understand caching at multiple layers (client, CDN, server, database) and how caches affect consistency and performance.",
        "masteryCriteria": [
          {
            "criteria": "Can identify caching layers",
            "mastered": false
          },
          {
            "criteria": "Can choose cache strategies",
            "mastered": false
          },
          {
            "criteria": "Can manage cache invalidation",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add caching to a system design",
            "completed": false
          },
          {
            "task": "Handle cache invalidation scenarios",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "caching-layers",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Redis Documentation",
          "AWS Caching Strategies"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Caching Layers: Speed at Every Level",
          "gist": "Explain how layered caching improves performance and its tradeoffs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T18-ST06",
        "title": "Failure modes",
        "details": "Learn to anticipate how systems fail, including partial failures, timeouts, and cascading failures.",
        "masteryCriteria": [
          {
            "criteria": "Can identify failure modes",
            "mastered": false
          },
          {
            "criteria": "Can design for graceful degradation",
            "mastered": false
          },
          {
            "criteria": "Can prevent cascading failures",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "List failure scenarios for a system",
            "completed": false
          },
          {
            "task": "Design fallback strategies",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "failure-modes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Failure Modes",
          "Resilience Engineering Concepts"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Failure Modes: Designing for Things That Go Wrong",
          "gist": "Explain why systems fail and how to design resilience.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T18-ST07",
        "title": "Tradeoff analysis",
        "details": "Understand how to evaluate architectural decisions by comparing tradeoffs across performance, cost, complexity, and maintainability.",
        "masteryCriteria": [
          {
            "criteria": "Can articulate tradeoffs clearly",
            "mastered": false
          },
          {
            "criteria": "Can avoid absolutist decisions",
            "mastered": false
          },
          {
            "criteria": "Can justify architectural choices",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Document tradeoffs for a design",
            "completed": false
          },
          {
            "task": "Compare alternative architectures",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "tradeoff-analysis",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Architecture Decision-Making Guides",
          "AWS Well-Architected Framework"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Tradeoff Analysis: The Core Skill of Architects",
          "gist": "Explain how good architecture is about informed tradeoffs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T18-ST08",
        "title": "Architecture diagrams",
        "details": "Learn how to create clear architecture diagrams that communicate system structure and data flow effectively.",
        "masteryCriteria": [
          {
            "criteria": "Can create clear architecture diagrams",
            "mastered": false
          },
          {
            "criteria": "Can choose appropriate diagram types",
            "mastered": false
          },
          {
            "criteria": "Can communicate design intent",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Draw architecture diagrams for a system",
            "completed": false
          },
          {
            "task": "Review diagrams with peers",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "diagram",
            "label": "architecture-diagrams",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "C4 Model Documentation",
          "AWS Architecture Icons"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Architecture Diagrams: Communicating Systems Clearly",
          "gist": "Explain how diagrams improve understanding and alignment.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T18-ST09",
        "title": "ADRs",
        "details": "Understand Architecture Decision Records as a way to document decisions, context, and consequences over time.",
        "masteryCriteria": [
          {
            "criteria": "Can write clear ADRs",
            "mastered": false
          },
          {
            "criteria": "Can document decision context",
            "mastered": false
          },
          {
            "criteria": "Can track architectural evolution",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write ADRs for key decisions",
            "completed": false
          },
          {
            "task": "Review historical ADRs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "adrs",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "ADR GitHub Repository",
          "ThoughtWorks ADR Guide"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Architecture Decision Records: Capturing the Why",
          "gist": "Explain why ADRs matter for long-lived systems.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T18-ST10",
        "title": "Evolutionary architecture",
        "details": "Learn how architectures evolve over time, enabling change without large rewrites or system instability.",
        "masteryCriteria": [
          {
            "criteria": "Can design for change",
            "mastered": false
          },
          {
            "criteria": "Can evolve architectures incrementally",
            "mastered": false
          },
          {
            "criteria": "Can avoid big-bang rewrites",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Plan architecture evolution",
            "completed": false
          },
          {
            "task": "Identify safe refactoring paths",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "evolutionary-architecture",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Building Evolutionary Architectures",
          "Martin Fowler - Evolutionary Architecture"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Evolutionary Architecture: Designing Systems That Can Change",
          "gist": "Explain how systems evolve safely over time.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T19",
    "title": "Documentation & Communication (What Makes Leads)",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "medium",
    "details": "This topic focuses on the written communication skills that distinguish senior engineers and technical leads. Mastery means you can document systems clearly, explain decisions and tradeoffs, onboard others efficiently, and communicate asynchronously with clarity and intent.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P6"
    ],
    "references": [
      "Google Engineering Practices - Documentation",
      "Write the Docs Community",
      "The Manager's Path - Camille Fournier"
    ],
    "subTasks": [
      {
        "id": "T19-ST01",
        "title": "README quality",
        "details": "Learn to write READMEs that clearly explain what a project is, how to run it, and how to contribute, without relying on tribal knowledge.",
        "masteryCriteria": [
          {
            "criteria": "Can write clear and complete READMEs",
            "mastered": false
          },
          {
            "criteria": "Can explain setup and usage concisely",
            "mastered": false
          },
          {
            "criteria": "Can anticipate reader questions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Rewrite an existing README",
            "completed": false
          },
          {
            "task": "Onboard someone using only the README",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "high-quality-readme",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Make a README Guide",
          "GitHub README Best Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "README Quality: The First Impression of Your Project",
          "gist": "Explain what makes a README useful and how poor READMEs slow teams down.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T19-ST02",
        "title": "API docs",
        "details": "Understand how to document APIs clearly so consumers can use them without back-and-forth communication.",
        "masteryCriteria": [
          {
            "criteria": "Can document endpoints clearly",
            "mastered": false
          },
          {
            "criteria": "Can describe request/response schemas",
            "mastered": false
          },
          {
            "criteria": "Can explain error cases",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write API documentation for an existing service",
            "completed": false
          },
          {
            "task": "Validate docs with a consumer",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "api-docs",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OpenAPI Specification",
          "Swagger Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "API Documentation: Reducing Friction for Consumers",
          "gist": "Explain why good API docs are a force multiplier for teams.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T19-ST03",
        "title": "Architecture docs",
        "details": "Learn to document system architecture so others can understand structure, data flow, and key responsibilities.",
        "masteryCriteria": [
          {
            "criteria": "Can explain system structure",
            "mastered": false
          },
          {
            "criteria": "Can document data flows",
            "mastered": false
          },
          {
            "criteria": "Can keep docs up to date",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create architecture documentation",
            "completed": false
          },
          {
            "task": "Review docs with stakeholders",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "architecture-docs",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "C4 Model Documentation",
          "Arc42 Architecture Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Architecture Documentation: Making Systems Understandable",
          "gist": "Explain how architecture docs reduce onboarding time and risk.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T19-ST04",
        "title": "Decision records",
        "details": "Understand decision records as a way to capture architectural and technical decisions along with context and consequences.",
        "masteryCriteria": [
          {
            "criteria": "Can write clear decision records",
            "mastered": false
          },
          {
            "criteria": "Can explain why decisions were made",
            "mastered": false
          },
          {
            "criteria": "Can avoid repeating past debates",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write decision records for key choices",
            "completed": false
          },
          {
            "task": "Review historical decisions",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "decision-records",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "ADR GitHub Repository",
          "ThoughtWorks ADR Guide"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Decision Records: Capturing the Why Behind Technical Choices",
          "gist": "Explain how decision records preserve institutional knowledge.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T19-ST05",
        "title": "Onboarding docs",
        "details": "Learn to create onboarding documentation that helps new team members become productive quickly and confidently.",
        "masteryCriteria": [
          {
            "criteria": "Can design onboarding flows",
            "mastered": false
          },
          {
            "criteria": "Can reduce onboarding time",
            "mastered": false
          },
          {
            "criteria": "Can eliminate dependency on verbal explanations",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create onboarding documentation",
            "completed": false
          },
          {
            "task": "Test onboarding with a new contributor",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "onboarding-docs",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "GitLab Onboarding Documentation",
          "Stripe Engineering Onboarding"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Onboarding Docs: Turning New Hires Into Contributors Faster",
          "gist": "Explain how good onboarding docs improve team velocity.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T19-ST06",
        "title": "Tech proposals",
        "details": "Understand how to write technical proposals that present problems, options, tradeoffs, and recommendations clearly.",
        "masteryCriteria": [
          {
            "criteria": "Can structure technical proposals",
            "mastered": false
          },
          {
            "criteria": "Can present tradeoffs objectively",
            "mastered": false
          },
          {
            "criteria": "Can influence decisions with clarity",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write a technical proposal",
            "completed": false
          },
          {
            "task": "Review and revise based on feedback",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "tech-proposals",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google Design Docs",
          "RFC Writing Guides"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Tech Proposals: Communicating Ideas That Get Adopted",
          "gist": "Explain how strong proposals align teams and reduce decision friction.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T19-ST07",
        "title": "Clear async communication",
        "details": "Learn to communicate clearly and concisely in asynchronous channels to avoid confusion, rework, and delays.",
        "masteryCriteria": [
          {
            "criteria": "Can write clear async messages",
            "mastered": false
          },
          {
            "criteria": "Can anticipate follow-up questions",
            "mastered": false
          },
          {
            "criteria": "Can reduce unnecessary meetings",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write async status updates",
            "completed": false
          },
          {
            "task": "Replace a meeting with written communication",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "async-communication",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "GitLab Handbook - Async Communication",
          "Basecamp - Shape Up Communication"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Clear Async Communication: Scaling Yourself as a Lead",
          "gist": "Explain why async communication is critical for modern teams.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T20",
    "title": "Career & Leverage Skills",
    "parentTopic": null,
    "priority": "high",
    "difficulty": "medium",
    "details": "This topic focuses on the non-code skills that compound technical ability into career growth and long-term leverage. Mastery means you create visible impact beyond individual tasks, grow others, think in systems and outcomes, and align technical decisions with business goals.",
    "projectsCoveredIn": [
      "P3",
      "P6",
      "P7"
    ],
    "references": [
      "The Staff Engineer's Path - Tanya Reilly",
      "The Manager's Path - Camille Fournier",
      "Stripe Engineering Blog"
    ],
    "subTasks": [
      {
        "id": "T20-ST01",
        "title": "Open source contributions",
        "details": "Learn how to contribute to open source projects by understanding codebases, collaborating asynchronously, and submitting high-quality pull requests.",
        "masteryCriteria": [
          {
            "criteria": "Can navigate unfamiliar codebases",
            "mastered": false
          },
          {
            "criteria": "Can submit meaningful pull requests",
            "mastered": false
          },
          {
            "criteria": "Can collaborate via issues and reviews",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Fix a bug or improve docs in an OSS project",
            "completed": false
          },
          {
            "task": "Participate in issue discussions",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "open-source-contributions",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "GitHub Open Source Guides",
          "First Contributions Repository"
        ],
        "estimatedHours": 4,
        "status": "not-started",
        "blog": {
          "title": "Open Source Contributions: Building Career Capital in Public",
          "gist": "Explain how open source work builds credibility, skills, and professional visibility.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T20-ST02",
        "title": "Writing technical blogs",
        "details": "Learn to write technical blogs that explain concepts clearly, share lessons learned, and demonstrate expertise.",
        "masteryCriteria": [
          {
            "criteria": "Can explain complex topics clearly",
            "mastered": false
          },
          {
            "criteria": "Can structure technical articles",
            "mastered": false
          },
          {
            "criteria": "Can write consistently",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write a technical blog post",
            "completed": false
          },
          {
            "task": "Publish and share learnings",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "technical-blog",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Write the Docs - Technical Writing",
          "Dev.to Writing Guides"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Writing Technical Blogs: Thinking Clearly in Public",
          "gist": "Explain how writing improves understanding and professional visibility.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T20-ST03",
        "title": "Mentoring juniors",
        "details": "Learn how to mentor junior engineers through guidance, feedback, and structured learning paths.",
        "masteryCriteria": [
          {
            "criteria": "Can provide constructive feedback",
            "mastered": false
          },
          {
            "criteria": "Can guide learning effectively",
            "mastered": false
          },
          {
            "criteria": "Can grow others without micromanaging",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Mentor a junior engineer",
            "completed": false
          },
          {
            "task": "Create a learning plan",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "mentoring-juniors",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google Engineering Mentorship",
          "The Manager's Path"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Mentoring Juniors: Multiplying Impact as an Engineer",
          "gist": "Explain how mentoring improves teams and leadership skills.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T20-ST04",
        "title": "System ownership",
        "details": "Understand system ownership as responsibility for reliability, evolution, and outcomes beyond feature delivery.",
        "masteryCriteria": [
          {
            "criteria": "Can own systems end-to-end",
            "mastered": false
          },
          {
            "criteria": "Can prioritize long-term health",
            "mastered": false
          },
          {
            "criteria": "Can respond to incidents",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Take ownership of a service",
            "completed": false
          },
          {
            "task": "Handle production issues",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "system-ownership",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Service Ownership",
          "The Staff Engineer's Path"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "System Ownership: Thinking Beyond Tickets",
          "gist": "Explain what it means to truly own a system.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T20-ST05",
        "title": "Cross-team collaboration",
        "details": "Learn to collaborate across teams by aligning goals, communicating clearly, and managing dependencies.",
        "masteryCriteria": [
          {
            "criteria": "Can align with other teams",
            "mastered": false
          },
          {
            "criteria": "Can manage cross-team dependencies",
            "mastered": false
          },
          {
            "criteria": "Can communicate tradeoffs clearly",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Lead a cross-team initiative",
            "completed": false
          },
          {
            "task": "Resolve dependency conflicts",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "cross-team-collaboration",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Team Topologies",
          "The Manager's Path"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Cross-Team Collaboration: Working Beyond Your Immediate Team",
          "gist": "Explain how collaboration scales impact in larger organizations.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T20-ST06",
        "title": "Product thinking",
        "details": "Understand product thinking as aligning technical decisions with user needs and business outcomes.",
        "masteryCriteria": [
          {
            "criteria": "Can think in terms of user value",
            "mastered": false
          },
          {
            "criteria": "Can balance tech and product needs",
            "mastered": false
          },
          {
            "criteria": "Can question requirements constructively",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Translate requirements into outcomes",
            "completed": false
          },
          {
            "task": "Propose product improvements",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "product-thinking",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Inspired - Marty Cagan",
          "Product Thinking Articles"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Product Thinking for Engineers",
          "gist": "Explain why engineers who think in products build better systems.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T20-ST07",
        "title": "Business awareness",
        "details": "Learn to understand business context, constraints, and priorities that influence technical decisions.",
        "masteryCriteria": [
          {
            "criteria": "Can understand business goals",
            "mastered": false
          },
          {
            "criteria": "Can align tech work with outcomes",
            "mastered": false
          },
          {
            "criteria": "Can communicate impact in business terms",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Map tech work to business goals",
            "completed": false
          },
          {
            "task": "Discuss tradeoffs with stakeholders",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "business-awareness",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Lean Startup Concepts",
          "Engineering for Business Value"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Business Awareness: Translating Code Into Impact",
          "gist": "Explain how business context improves technical decisions.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T20-ST08",
        "title": "SaaS metrics (MRR, churn, CAC)",
        "details": "Understand key SaaS metrics that measure growth, retention, and acquisition efficiency.",
        "masteryCriteria": [
          {
            "criteria": "Can explain core SaaS metrics",
            "mastered": false
          },
          {
            "criteria": "Can calculate basic metrics",
            "mastered": false
          },
          {
            "criteria": "Can relate metrics to product decisions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Calculate SaaS metrics from sample data",
            "completed": false
          },
          {
            "task": "Analyze metric trends",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "saas-metrics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "SaaStr Metrics Guide",
          "Stripe SaaS Metrics Blog"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "SaaS Metrics Every Technical Leader Should Understand",
          "gist": "Explain MRR, churn, CAC, and why they matter to engineering decisions.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T21",
    "title": "Operating Systems & Low-Level Runtime Awareness",
    "parentTopic": "T01",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic builds essential awareness of what actually runs your code at runtime. Mastery means you can reason about performance, reliability, and failures by understanding processes, threads, memory, I/O, and OS constraints\u2014without needing to be a kernel engineer.",
    "projectsCoveredIn": [
      "P1",
      "P2",
      "P5"
    ],
    "references": [
      "Operating Systems: Three Easy Pieces",
      "Node.js Documentation",
      "Linux Man Pages (conceptual)"
    ],
    "subTasks": [
      {
        "id": "T21-ST01",
        "title": "Process vs thread",
        "details": "Understand the difference between processes and threads, including isolation, memory sharing, and scheduling implications.",
        "masteryCriteria": [
          {
            "criteria": "Can explain processes vs threads",
            "mastered": false
          },
          {
            "criteria": "Can explain memory isolation",
            "mastered": false
          },
          {
            "criteria": "Can relate concepts to Node.js",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Inspect running processes and threads",
            "completed": false
          },
          {
            "task": "Map Node processes to OS concepts",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "process-vs-thread",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OSTEP - Processes",
          "Node.js Process Model"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Process vs Thread: What Your Application Actually Runs On",
          "gist": "Explain processes and threads and why the distinction matters for backend systems.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T21-ST02",
        "title": "Context switching (high-level)",
        "details": "Understand context switching conceptually: how CPUs switch between execution contexts and why excessive context switching hurts performance.",
        "masteryCriteria": [
          {
            "criteria": "Can explain context switching",
            "mastered": false
          },
          {
            "criteria": "Can explain scheduling overhead",
            "mastered": false
          },
          {
            "criteria": "Can relate switching cost to performance",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Observe CPU scheduling behavior",
            "completed": false
          },
          {
            "task": "Identify context-switch-heavy scenarios",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "context-switching",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OSTEP - Scheduling",
          "Linux Scheduler Overview"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Context Switching: The Hidden Cost of Concurrency",
          "gist": "Explain why switching between tasks isn't free and how it impacts throughput.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T21-ST03",
        "title": "File descriptors",
        "details": "Understand file descriptors as OS-level handles for files, sockets, and streams, and why they are a limited resource.",
        "masteryCriteria": [
          {
            "criteria": "Can explain what file descriptors are",
            "mastered": false
          },
          {
            "criteria": "Can identify FD leaks",
            "mastered": false
          },
          {
            "criteria": "Can relate sockets to FDs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Inspect open file descriptors",
            "completed": false
          },
          {
            "task": "Simulate file descriptor exhaustion",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "file-descriptors",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Linux File Descriptor Docs",
          "Node.js fs and net Internals"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "File Descriptors: The OS Resource You Can Run Out Of",
          "gist": "Explain file descriptors and why leaking them crashes servers.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T21-ST04",
        "title": "Blocking vs non-blocking IO",
        "details": "Understand blocking and non-blocking I/O models and why non-blocking I/O enables high concurrency in Node.js.",
        "masteryCriteria": [
          {
            "criteria": "Can explain blocking vs non-blocking IO",
            "mastered": false
          },
          {
            "criteria": "Can identify blocking operations",
            "mastered": false
          },
          {
            "criteria": "Can avoid blocking the event loop",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write blocking vs non-blocking examples",
            "completed": false
          },
          {
            "task": "Measure impact on concurrency",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "blocking-vs-nonblocking-io",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Node.js Event Loop Docs",
          "libuv I/O Model"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Blocking vs Non-Blocking I/O: Why Node Scales",
          "gist": "Explain how non-blocking I/O enables high throughput.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T21-ST05",
        "title": "How Node uses libuv",
        "details": "Understand libuv as the abstraction layer that provides Node.js with cross-platform asynchronous I/O and a thread pool.",
        "masteryCriteria": [
          {
            "criteria": "Can explain libuv's role",
            "mastered": false
          },
          {
            "criteria": "Can explain the thread pool",
            "mastered": false
          },
          {
            "criteria": "Can identify libuv-related bottlenecks",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Trace async operations to libuv",
            "completed": false
          },
          {
            "task": "Identify thread pool saturation",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "node-libuv",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "libuv Documentation",
          "Node.js Internals Guides"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "How Node.js Uses libuv Under the Hood",
          "gist": "Explain why libuv exists and how it enables async I/O.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T21-ST06",
        "title": "Syscalls (conceptual)",
        "details": "Understand system calls as the boundary between user-space programs and the operating system kernel.",
        "masteryCriteria": [
          {
            "criteria": "Can explain what syscalls are",
            "mastered": false
          },
          {
            "criteria": "Can explain why syscalls are expensive",
            "mastered": false
          },
          {
            "criteria": "Can relate syscalls to I/O operations",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Map high-level operations to syscalls",
            "completed": false
          },
          {
            "task": "Inspect syscall-heavy operations",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "syscalls",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Linux System Call Overview",
          "OSTEP - System Calls"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "System Calls: Crossing the Boundary to the Kernel",
          "gist": "Explain how applications ask the OS to do work.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T21-ST07",
        "title": "Memory pages",
        "details": "Understand memory pages, virtual memory, and how memory is allocated and managed by the OS.",
        "masteryCriteria": [
          {
            "criteria": "Can explain memory paging",
            "mastered": false
          },
          {
            "criteria": "Can explain virtual memory",
            "mastered": false
          },
          {
            "criteria": "Can relate memory pressure to performance",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Observe memory usage patterns",
            "completed": false
          },
          {
            "task": "Trigger and analyze memory pressure",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "memory-pages",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OSTEP - Virtual Memory",
          "Linux Memory Management Overview"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Memory Pages: How Your Program Uses RAM",
          "gist": "Explain paging and why memory behavior affects performance.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T21-ST08",
        "title": "Why \u201cCPU-bound\u201d kills Node",
        "details": "Understand why CPU-bound tasks block the event loop and how this degrades throughput and latency in Node.js.",
        "masteryCriteria": [
          {
            "criteria": "Can explain event loop blocking",
            "mastered": false
          },
          {
            "criteria": "Can identify CPU-bound workloads",
            "mastered": false
          },
          {
            "criteria": "Can offload CPU work safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Simulate CPU-bound blocking",
            "completed": false
          },
          {
            "task": "Move CPU work off the main thread",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "cpu-bound-node",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Node.js Worker Threads Docs",
          "libuv Thread Pool"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Why CPU-Bound Work Kills Node.js Performance",
          "gist": "Explain event loop blocking and mitigation strategies.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T21-ST09",
        "title": "OS limits (ulimits, open files)",
        "details": "Understand OS-imposed limits such as maximum open files and processes, and how exceeding them causes production failures.",
        "masteryCriteria": [
          {
            "criteria": "Can explain OS limits",
            "mastered": false
          },
          {
            "criteria": "Can inspect and adjust limits",
            "mastered": false
          },
          {
            "criteria": "Can prevent resource exhaustion",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Inspect ulimit settings",
            "completed": false
          },
          {
            "task": "Trigger limit-related failures safely",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "os-limits",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Linux ulimit Documentation",
          "Node.js Production Best Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "OS Limits: Invisible Constraints That Break Systems",
          "gist": "Explain how OS limits affect real-world server stability.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T21-ST10",
        "title": "Timeouts & signals (SIGTERM, SIGINT)",
        "details": "Understand Unix signals, graceful shutdown, and how processes receive and handle termination signals.",
        "masteryCriteria": [
          {
            "criteria": "Can explain SIGTERM vs SIGINT",
            "mastered": false
          },
          {
            "criteria": "Can implement graceful shutdown",
            "mastered": false
          },
          {
            "criteria": "Can handle timeouts correctly",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Handle SIGTERM in a Node app",
            "completed": false
          },
          {
            "task": "Implement graceful shutdown logic",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "signals-timeouts",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Node.js Process Signals Docs",
          "Unix Signal Handling"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Timeouts and Signals: Shutting Down Services Safely",
          "gist": "Explain why graceful shutdown matters in production systems.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T22",
    "title": "Advanced Networking & Distributed Systems (Real-World Scale)",
    "parentTopic": "T09",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic deepens networking and distributed-systems understanding beyond basic HTTP. Mastery means you can reason about connections, protocols, latency, failure handling, and traffic management at real-world scale, and design systems that remain stable under load and partial failure.",
    "projectsCoveredIn": [
      "P2",
      "P5",
      "P6"
    ],
    "references": [
      "Designing Data-Intensive Applications - Martin Kleppmann",
      "Google SRE Book - Networking",
      "Cloudflare Learning Center"
    ],
    "subTasks": [
      {
        "id": "T22-ST01",
        "title": "TCP vs UDP",
        "details": "Understand the fundamental differences between TCP and UDP, including reliability, ordering, congestion control, and common use cases.",
        "masteryCriteria": [
          {
            "criteria": "Can explain TCP and UDP differences",
            "mastered": false
          },
          {
            "criteria": "Can choose appropriate protocol",
            "mastered": false
          },
          {
            "criteria": "Can relate protocol choice to application behavior",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Compare TCP and UDP use cases",
            "completed": false
          },
          {
            "task": "Trace packet flow for each protocol",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "tcp-vs-udp",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "RFC 793 (TCP)",
          "RFC 768 (UDP)"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "TCP vs UDP: Choosing the Right Transport Protocol",
          "gist": "Explain how transport protocol choice affects reliability and performance.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T22-ST02",
        "title": "Connection lifecycle",
        "details": "Understand how network connections are established, maintained, and closed, including handshakes and teardown.",
        "masteryCriteria": [
          {
            "criteria": "Can explain connection setup and teardown",
            "mastered": false
          },
          {
            "criteria": "Can identify connection leaks",
            "mastered": false
          },
          {
            "criteria": "Can reason about connection reuse",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Trace connection lifecycles",
            "completed": false
          },
          {
            "task": "Debug connection exhaustion",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "connection-lifecycle",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "TCP Connection Establishment",
          "HTTP Connection Management"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Connection Lifecycle: From Handshake to Teardown",
          "gist": "Explain what happens when connections open and close.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T22-ST03",
        "title": "Head-of-line blocking",
        "details": "Understand head-of-line blocking and how it impacts throughput and latency in networking protocols.",
        "masteryCriteria": [
          {
            "criteria": "Can explain head-of-line blocking",
            "mastered": false
          },
          {
            "criteria": "Can identify affected protocols",
            "mastered": false
          },
          {
            "criteria": "Can explain mitigation strategies",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze HOL blocking scenarios",
            "completed": false
          },
          {
            "task": "Compare protocol behaviors",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "head-of-line-blocking",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "HTTP/2 HOL Blocking Explanations",
          "QUIC Protocol Overview"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Head-of-Line Blocking: The Hidden Performance Killer",
          "gist": "Explain how HOL blocking limits performance and how modern protocols address it.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T22-ST04",
        "title": "HTTP/1.1 vs HTTP/2 vs HTTP/3",
        "details": "Understand differences between HTTP versions, including multiplexing, header compression, and transport layers.",
        "masteryCriteria": [
          {
            "criteria": "Can compare HTTP versions",
            "mastered": false
          },
          {
            "criteria": "Can explain performance implications",
            "mastered": false
          },
          {
            "criteria": "Can choose appropriate protocol versions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Inspect HTTP versions in use",
            "completed": false
          },
          {
            "task": "Measure performance differences",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "http-versions",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "RFC 7540 (HTTP/2)",
          "RFC 9114 (HTTP/3)"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "HTTP/1.1 vs HTTP/2 vs HTTP/3: How the Web Evolved",
          "gist": "Explain why newer HTTP versions exist and what problems they solve.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T22-ST05",
        "title": "Keep-alive",
        "details": "Understand connection keep-alive mechanisms and how they reduce latency and resource usage.",
        "masteryCriteria": [
          {
            "criteria": "Can explain keep-alive behavior",
            "mastered": false
          },
          {
            "criteria": "Can tune keep-alive settings",
            "mastered": false
          },
          {
            "criteria": "Can avoid connection churn",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Configure keep-alive settings",
            "completed": false
          },
          {
            "task": "Observe impact on latency",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "keep-alive",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "HTTP Persistent Connections",
          "NGINX Keep-Alive Docs"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Keep-Alive Connections: Faster Requests, Fewer Costs",
          "gist": "Explain how persistent connections improve performance.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T22-ST06",
        "title": "Load balancing strategies",
        "details": "Understand different load balancing strategies such as round-robin, least-connections, and hashing.",
        "masteryCriteria": [
          {
            "criteria": "Can explain load balancing algorithms",
            "mastered": false
          },
          {
            "criteria": "Can choose appropriate strategies",
            "mastered": false
          },
          {
            "criteria": "Can handle uneven traffic",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Configure load balancing strategies",
            "completed": false
          },
          {
            "task": "Test traffic distribution",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "load-balancing-strategies",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "NGINX Load Balancing Algorithms",
          "AWS Load Balancing Strategies"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Load Balancing Strategies: Spreading Traffic Intelligently",
          "gist": "Explain how different load balancing strategies affect system behavior.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T22-ST07",
        "title": "Reverse proxies",
        "details": "Understand reverse proxies as intermediaries that route, secure, and optimize traffic to backend services.",
        "masteryCriteria": [
          {
            "criteria": "Can explain reverse proxy roles",
            "mastered": false
          },
          {
            "criteria": "Can configure reverse proxies",
            "mastered": false
          },
          {
            "criteria": "Can avoid misconfiguration pitfalls",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Set up a reverse proxy",
            "completed": false
          },
          {
            "task": "Route traffic to multiple services",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "reverse-proxies",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "NGINX Reverse Proxy Docs",
          "HAProxy Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Reverse Proxies: The Traffic Directors of the Web",
          "gist": "Explain how reverse proxies improve security and scalability.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T22-ST08",
        "title": "CDN internals",
        "details": "Understand how CDNs cache and serve content globally, reducing latency and origin load.",
        "masteryCriteria": [
          {
            "criteria": "Can explain CDN architecture",
            "mastered": false
          },
          {
            "criteria": "Can configure caching rules",
            "mastered": false
          },
          {
            "criteria": "Can debug CDN behavior",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Deploy content behind a CDN",
            "completed": false
          },
          {
            "task": "Analyze cache hit ratios",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "cdn-internals",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Cloudflare CDN Architecture",
          "AWS CloudFront Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "CDN Internals: How Content Gets Closer to Users",
          "gist": "Explain how CDNs reduce latency and scale delivery.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T22-ST09",
        "title": "NAT & IP basics",
        "details": "Understand IP addressing and Network Address Translation and how they affect connectivity and routing.",
        "masteryCriteria": [
          {
            "criteria": "Can explain IP addressing",
            "mastered": false
          },
          {
            "criteria": "Can explain NAT behavior",
            "mastered": false
          },
          {
            "criteria": "Can troubleshoot NAT-related issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Trace IP routing paths",
            "completed": false
          },
          {
            "task": "Analyze NAT configurations",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "nat-ip-basics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "IP Addressing Basics",
          "NAT Concepts Documentation"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "NAT and IP Basics: How Traffic Moves Across Networks",
          "gist": "Explain NAT, IP addressing, and common networking pitfalls.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T22-ST10",
        "title": "DNS resolution flow",
        "details": "Understand the step-by-step DNS resolution process from client to authoritative servers.",
        "masteryCriteria": [
          {
            "criteria": "Can explain DNS resolution flow",
            "mastered": false
          },
          {
            "criteria": "Can identify DNS bottlenecks",
            "mastered": false
          },
          {
            "criteria": "Can debug DNS-related latency",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Trace DNS lookups",
            "completed": false
          },
          {
            "task": "Inspect resolver behavior",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "dns-resolution-flow",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "How DNS Works - Cloudflare",
          "DNS RFC Overview"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "DNS Resolution Flow: From Domain Name to IP Address",
          "gist": "Explain the DNS lookup process in detail.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T22-ST11",
        "title": "Latency vs throughput",
        "details": "Understand the difference between latency and throughput and why optimizing one can hurt the other.",
        "masteryCriteria": [
          {
            "criteria": "Can define latency and throughput",
            "mastered": false
          },
          {
            "criteria": "Can analyze tradeoffs",
            "mastered": false
          },
          {
            "criteria": "Can optimize based on goals",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Measure latency and throughput",
            "completed": false
          },
          {
            "task": "Analyze performance tradeoffs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "latency-vs-throughput",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Latency vs Throughput",
          "Performance Engineering Articles"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Latency vs Throughput: Choosing the Right Performance Metric",
          "gist": "Explain why performance is more than just speed.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T22-ST12",
        "title": "Backpressure",
        "details": "Understand backpressure as a mechanism to prevent fast producers from overwhelming slower consumers.",
        "masteryCriteria": [
          {
            "criteria": "Can explain backpressure",
            "mastered": false
          },
          {
            "criteria": "Can identify backpressure failures",
            "mastered": false
          },
          {
            "criteria": "Can apply flow control mechanisms",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement backpressure handling",
            "completed": false
          },
          {
            "task": "Simulate overload scenarios",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "backpressure",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Reactive Streams Specification",
          "Akka Backpressure Concepts"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Backpressure: Protecting Systems From Overload",
          "gist": "Explain why backpressure is critical in distributed systems.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T22-ST13",
        "title": "Circuit breakers",
        "details": "Understand circuit breakers as a resilience pattern that prevents cascading failures.",
        "masteryCriteria": [
          {
            "criteria": "Can explain circuit breaker states",
            "mastered": false
          },
          {
            "criteria": "Can implement circuit breakers",
            "mastered": false
          },
          {
            "criteria": "Can tune breaker thresholds",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add circuit breakers to service calls",
            "completed": false
          },
          {
            "task": "Test failure isolation",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "circuit-breakers",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Martin Fowler - Circuit Breaker",
          "Resilience4j Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Circuit Breakers: Stopping Cascading Failures",
          "gist": "Explain how circuit breakers improve system resilience.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T22-ST14",
        "title": "Timeouts everywhere philosophy",
        "details": "Understand the philosophy of applying timeouts at every network boundary to prevent resource exhaustion and cascading failures.",
        "masteryCriteria": [
          {
            "criteria": "Can justify timeouts everywhere",
            "mastered": false
          },
          {
            "criteria": "Can configure sensible timeout values",
            "mastered": false
          },
          {
            "criteria": "Can avoid indefinite waits",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add timeouts across services",
            "completed": false
          },
          {
            "task": "Audit missing timeout configurations",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "timeouts-everywhere",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Timeouts",
          "Distributed Systems Reliability Guides"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Timeouts Everywhere: The Golden Rule of Distributed Systems",
          "gist": "Explain why timeouts are mandatory in distributed systems.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T23",
    "title": "Caching \u2014 Deep, Layered, Dangerous",
    "parentTopic": "T12",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic covers caching as a powerful but risky performance tool. Mastery means you understand different caching patterns, layering strategies, invalidation problems, consistency tradeoffs, and how caching failures can take systems down.",
    "projectsCoveredIn": [
      "P2",
      "P5",
      "P6"
    ],
    "references": [
      "Designing Data-Intensive Applications - Martin Kleppmann",
      "Redis Documentation",
      "AWS Caching Best Practices"
    ],
    "subTasks": [
      {
        "id": "T23-ST01",
        "title": "Cache-aside vs write-through",
        "details": "Understand cache-aside and write-through caching patterns, including data flow, failure modes, and consistency implications.",
        "masteryCriteria": [
          {
            "criteria": "Can explain cache-aside vs write-through",
            "mastered": false
          },
          {
            "criteria": "Can choose an appropriate pattern",
            "mastered": false
          },
          {
            "criteria": "Can reason about consistency tradeoffs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement both cache patterns",
            "completed": false
          },
          {
            "task": "Compare behavior under failures",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "cache-patterns",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS Cache Patterns",
          "Martin Fowler - Cache Patterns"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Cache-Aside vs Write-Through: Choosing the Right Caching Pattern",
          "gist": "Explain how different caching patterns affect consistency, latency, and failure handling.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T23-ST02",
        "title": "Stale-while-revalidate",
        "details": "Understand the stale-while-revalidate strategy that serves stale data while refreshing cache entries asynchronously.",
        "masteryCriteria": [
          {
            "criteria": "Can explain stale-while-revalidate",
            "mastered": false
          },
          {
            "criteria": "Can identify suitable use cases",
            "mastered": false
          },
          {
            "criteria": "Can handle background refresh safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement stale-while-revalidate",
            "completed": false
          },
          {
            "task": "Measure latency improvements",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "stale-while-revalidate",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "HTTP Cache-Control RFC",
          "CDN Caching Strategies"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Stale-While-Revalidate: Faster Responses Without Full Freshness",
          "gist": "Explain how stale-while-revalidate balances freshness and performance.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T23-ST03",
        "title": "TTL strategies",
        "details": "Learn how to choose appropriate TTL values based on data volatility, access patterns, and consistency requirements.",
        "masteryCriteria": [
          {
            "criteria": "Can choose effective TTLs",
            "mastered": false
          },
          {
            "criteria": "Can avoid overly aggressive expiration",
            "mastered": false
          },
          {
            "criteria": "Can tune TTLs based on metrics",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Configure TTLs for different data types",
            "completed": false
          },
          {
            "task": "Observe cache hit/miss ratios",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "ttl-strategies",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Redis TTL Documentation",
          "Caching TTL Best Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "TTL Strategies: How Long Should Data Live in Cache?",
          "gist": "Explain how TTL decisions impact freshness and load.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T23-ST04",
        "title": "Cache invalidation strategies",
        "details": "Understand cache invalidation as one of the hardest problems in distributed systems and learn common strategies.",
        "masteryCriteria": [
          {
            "criteria": "Can explain invalidation strategies",
            "mastered": false
          },
          {
            "criteria": "Can avoid stale data bugs",
            "mastered": false
          },
          {
            "criteria": "Can design safe invalidation flows",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement cache invalidation",
            "completed": false
          },
          {
            "task": "Test stale data scenarios",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "cache-invalidation",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Two Hard Things - Phil Karlton",
          "Distributed Cache Invalidation Patterns"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Cache Invalidation: The Hardest Problem in Computer Science",
          "gist": "Explain why cache invalidation is hard and how to handle it safely.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T23-ST05",
        "title": "Client vs server caching",
        "details": "Understand the differences between client-side and server-side caching and how they interact.",
        "masteryCriteria": [
          {
            "criteria": "Can distinguish client vs server caching",
            "mastered": false
          },
          {
            "criteria": "Can design layered caching",
            "mastered": false
          },
          {
            "criteria": "Can prevent conflicting cache behavior",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement both caching layers",
            "completed": false
          },
          {
            "task": "Debug inconsistent cache behavior",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "client-vs-server-caching",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "HTTP Caching MDN",
          "Web Performance Caching Guides"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Client vs Server Caching: Where Should Data Live?",
          "gist": "Explain how caching responsibilities differ between client and server.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T23-ST06",
        "title": "CDN caching headers",
        "details": "Learn how HTTP caching headers control CDN behavior, cacheability, and revalidation.",
        "masteryCriteria": [
          {
            "criteria": "Can configure cache-control headers",
            "mastered": false
          },
          {
            "criteria": "Can influence CDN caching",
            "mastered": false
          },
          {
            "criteria": "Can debug CDN cache misses",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Set CDN cache headers",
            "completed": false
          },
          {
            "task": "Verify cache behavior",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "cdn-caching-headers",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Cloudflare Cache-Control Guide",
          "AWS CloudFront Cache Policies"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "CDN Caching Headers: Controlling the Edge",
          "gist": "Explain how headers control CDN caching behavior.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T23-ST07",
        "title": "Redis eviction policies",
        "details": "Understand Redis eviction policies and how memory pressure affects cached data.",
        "masteryCriteria": [
          {
            "criteria": "Can explain eviction policies",
            "mastered": false
          },
          {
            "criteria": "Can choose correct policy",
            "mastered": false
          },
          {
            "criteria": "Can prevent unexpected evictions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Configure eviction policies",
            "completed": false
          },
          {
            "task": "Observe behavior under memory pressure",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "redis-eviction",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Redis Eviction Policies Docs",
          "Redis Memory Management"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Redis Eviction Policies: What Gets Deleted When Memory Runs Out",
          "gist": "Explain how Redis decides which keys to evict.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T23-ST08",
        "title": "Cache stampede prevention",
        "details": "Understand cache stampedes and techniques to prevent sudden backend overloads when caches expire.",
        "masteryCriteria": [
          {
            "criteria": "Can explain cache stampedes",
            "mastered": false
          },
          {
            "criteria": "Can implement prevention techniques",
            "mastered": false
          },
          {
            "criteria": "Can protect backend systems",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Simulate cache stampede",
            "completed": false
          },
          {
            "task": "Add locking or request coalescing",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "cache-stampede",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS Cache Stampede Prevention",
          "Distributed Locking Patterns"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Cache Stampedes: When Caching Takes Systems Down",
          "gist": "Explain stampede scenarios and mitigation strategies.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T23-ST09",
        "title": "Negative caching",
        "details": "Learn negative caching to store and reuse negative results like misses or errors to reduce repeated load.",
        "masteryCriteria": [
          {
            "criteria": "Can explain negative caching",
            "mastered": false
          },
          {
            "criteria": "Can identify safe use cases",
            "mastered": false
          },
          {
            "criteria": "Can avoid caching harmful errors",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement negative caching",
            "completed": false
          },
          {
            "task": "Test error caching behavior",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "negative-caching",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Caching Negative Results Patterns",
          "High Scalability Blog"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Negative Caching: Caching Failures on Purpose",
          "gist": "Explain when caching negative results helps and when it hurts.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T23-ST10",
        "title": "Consistency vs freshness tradeoffs",
        "details": "Understand the tradeoff between data consistency and freshness when caching across distributed systems.",
        "masteryCriteria": [
          {
            "criteria": "Can explain consistency vs freshness",
            "mastered": false
          },
          {
            "criteria": "Can justify tradeoffs",
            "mastered": false
          },
          {
            "criteria": "Can align caching strategy with requirements",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Evaluate tradeoffs for real systems",
            "completed": false
          },
          {
            "task": "Document caching decisions",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "consistency-vs-freshness",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "CAP Theorem Discussions",
          "Designing Data-Intensive Applications"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Consistency vs Freshness: The Core Caching Tradeoff",
          "gist": "Explain why caching always involves compromise.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T24",
    "title": "Data Consistency & Failure Modes",
    "parentTopic": "T22",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic focuses on how distributed systems behave when things go wrong. Mastery means you understand consistency models, failure patterns, and why correctness is probabilistic\u2014not guaranteed\u2014at scale.",
    "projectsCoveredIn": [
      "P5",
      "P6"
    ],
    "references": [
      "Designing Data-Intensive Applications - Martin Kleppmann",
      "Google SRE Book - Handling Failures",
      "AWS Builders Library - Timeouts and Retries"
    ],
    "subTasks": [
      {
        "id": "T24-ST01",
        "title": "Eventual consistency",
        "details": "Understand eventual consistency as a model where replicas converge over time, not immediately.",
        "masteryCriteria": [
          {
            "criteria": "Can explain eventual consistency",
            "mastered": false
          },
          {
            "criteria": "Can identify acceptable use cases",
            "mastered": false
          },
          {
            "criteria": "Can explain stale reads",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Design an eventually consistent flow",
            "completed": false
          },
          {
            "task": "Reason about stale data scenarios",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "eventual-consistency",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Kleppmann - Consistency Models",
          "AWS DynamoDB Consistency Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Eventual Consistency: When Correctness Takes Time",
          "gist": "Explain why eventual consistency exists and how systems converge.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T24-ST02",
        "title": "Strong consistency",
        "details": "Understand strong consistency guarantees and the cost required to enforce them in distributed systems.",
        "masteryCriteria": [
          {
            "criteria": "Can explain strong consistency",
            "mastered": false
          },
          {
            "criteria": "Can compare to eventual consistency",
            "mastered": false
          },
          {
            "criteria": "Can explain latency tradeoffs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Design a strongly consistent workflow",
            "completed": false
          },
          {
            "task": "Measure coordination overhead",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "strong-consistency",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Linearizability Explained",
          "Kleppmann - Consistency Guarantees"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Strong Consistency: Guarantees That Come at a Cost",
          "gist": "Explain what strong consistency guarantees\u2014and what it costs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T24-ST03",
        "title": "CAP theorem (practical meaning)",
        "details": "Understand the CAP theorem beyond theory: how real systems trade consistency, availability, and partition tolerance.",
        "masteryCriteria": [
          {
            "criteria": "Can explain CAP in practical terms",
            "mastered": false
          },
          {
            "criteria": "Can identify real-world tradeoffs",
            "mastered": false
          },
          {
            "criteria": "Can avoid CAP misconceptions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze CAP tradeoffs in real systems",
            "completed": false
          },
          {
            "task": "Debunk common CAP myths",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "cap-theorem",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Brewer's CAP Theorem",
          "Kleppmann - CAP Clarified"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "CAP Theorem: What It Actually Means in Production",
          "gist": "Explain CAP using real-world system behavior, not theory alone.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T24-ST04",
        "title": "Idempotent operations",
        "details": "Understand idempotency and why it is essential for safe retries in distributed systems.",
        "masteryCriteria": [
          {
            "criteria": "Can define idempotency",
            "mastered": false
          },
          {
            "criteria": "Can design idempotent APIs",
            "mastered": false
          },
          {
            "criteria": "Can prevent duplicate side effects",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Design idempotent endpoints",
            "completed": false
          },
          {
            "task": "Handle retry scenarios safely",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "idempotent-operations",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "REST Idempotency Concepts",
          "Stripe Idempotency Keys"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Idempotent Operations: The Foundation of Safe Retries",
          "gist": "Explain how idempotency prevents duplicate writes.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T24-ST05",
        "title": "Retry storms",
        "details": "Understand retry storms and how uncoordinated retries amplify failures.",
        "masteryCriteria": [
          {
            "criteria": "Can explain retry storms",
            "mastered": false
          },
          {
            "criteria": "Can identify retry amplification",
            "mastered": false
          },
          {
            "criteria": "Can design controlled retry logic",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Simulate retry storms",
            "completed": false
          },
          {
            "task": "Apply backoff and jitter",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "retry-storms",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS Retry Backoff Guidance",
          "Google SRE - Retries"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Retry Storms: When Recovery Makes Things Worse",
          "gist": "Explain how retries can overload failing systems.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T24-ST06",
        "title": "Duplicate message handling",
        "details": "Understand why duplicate messages occur and how systems must handle them safely.",
        "masteryCriteria": [
          {
            "criteria": "Can explain why duplicates happen",
            "mastered": false
          },
          {
            "criteria": "Can design deduplication logic",
            "mastered": false
          },
          {
            "criteria": "Can tolerate reprocessing",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Handle duplicate events",
            "completed": false
          },
          {
            "task": "Implement deduplication keys",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "duplicate-message-handling",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Messaging Semantics Docs",
          "Kafka Delivery Guarantees"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Duplicate Messages: Designing for the Inevitable",
          "gist": "Explain why duplicates are normal in distributed systems.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T24-ST07",
        "title": "Exactly-once illusion",
        "details": "Understand why exactly-once processing is mostly an illusion and what systems actually provide.",
        "masteryCriteria": [
          {
            "criteria": "Can explain exactly-once illusion",
            "mastered": false
          },
          {
            "criteria": "Can explain at-least-once semantics",
            "mastered": false
          },
          {
            "criteria": "Can design safe processing logic",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze messaging guarantees",
            "completed": false
          },
          {
            "task": "Design idempotent consumers",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "exactly-once-illusion",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Kleppmann - Exactly Once Semantics",
          "Kafka Exactly-Once Semantics"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "The Exactly-Once Illusion in Distributed Systems",
          "gist": "Explain why exactly-once is rarely achievable.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T24-ST08",
        "title": "Dead-letter queues",
        "details": "Understand dead-letter queues as a way to isolate and inspect failed messages.",
        "masteryCriteria": [
          {
            "criteria": "Can explain DLQs",
            "mastered": false
          },
          {
            "criteria": "Can configure DLQs",
            "mastered": false
          },
          {
            "criteria": "Can design failure workflows",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Configure a DLQ",
            "completed": false
          },
          {
            "task": "Reprocess failed messages",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "dead-letter-queues",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS SQS DLQ Docs",
          "Kafka DLQ Patterns"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Dead-Letter Queues: Where Failed Messages Go",
          "gist": "Explain how DLQs prevent poison message loops.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T24-ST09",
        "title": "Poison messages",
        "details": "Understand poison messages and how they can repeatedly crash consumers.",
        "masteryCriteria": [
          {
            "criteria": "Can identify poison messages",
            "mastered": false
          },
          {
            "criteria": "Can prevent infinite retries",
            "mastered": false
          },
          {
            "criteria": "Can quarantine bad data",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Simulate poison messages",
            "completed": false
          },
          {
            "task": "Route failures safely",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "poison-messages",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Messaging Failure Handling Patterns",
          "AWS Messaging Best Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Poison Messages: The Silent Queue Killers",
          "gist": "Explain how poison messages bring systems down silently.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T24-ST10",
        "title": "Partial failures",
        "details": "Understand partial failures where some components fail while others continue operating.",
        "masteryCriteria": [
          {
            "criteria": "Can explain partial failures",
            "mastered": false
          },
          {
            "criteria": "Can design graceful degradation",
            "mastered": false
          },
          {
            "criteria": "Can detect partial outages",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Design fallback mechanisms",
            "completed": false
          },
          {
            "task": "Simulate partial outages",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "partial-failures",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Partial Failures",
          "Resilience Engineering"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Partial Failures: The Default State of Distributed Systems",
          "gist": "Explain why systems fail partially, not completely.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T24-ST11",
        "title": "Time synchronization issues",
        "details": "Understand clock drift, skew, and why time cannot be trusted in distributed systems.",
        "masteryCriteria": [
          {
            "criteria": "Can explain clock drift",
            "mastered": false
          },
          {
            "criteria": "Can explain time skew issues",
            "mastered": false
          },
          {
            "criteria": "Can avoid time-based assumptions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze time skew effects",
            "completed": false
          },
          {
            "task": "Design time-safe systems",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "time-synchronization",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Kleppmann - Time and Ordering",
          "NTP Protocol Overview"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Time Synchronization Issues: Why Time Lies in Distributed Systems",
          "gist": "Explain why relying on clocks causes subtle bugs.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T25",
    "title": "Advanced API & Contract Design",
    "parentTopic": "T09",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic focuses on designing APIs that can survive years of change. Mastery means you can evolve APIs safely, avoid breaking consumers, formalize contracts, and design interfaces that scale with both traffic and teams.",
    "projectsCoveredIn": [
      "P2",
      "P5",
      "P6"
    ],
    "references": [
      "API Design Patterns - Microsoft",
      "Stripe API Design Guidelines",
      "OpenAPI Specification"
    ],
    "subTasks": [
      {
        "id": "T25-ST01",
        "title": "API versioning strategies",
        "details": "Understand different API versioning strategies and their long-term impact on consumers and maintainability.",
        "masteryCriteria": [
          {
            "criteria": "Can explain common versioning approaches",
            "mastered": false
          },
          {
            "criteria": "Can choose appropriate strategy",
            "mastered": false
          },
          {
            "criteria": "Can manage multiple versions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Design a versioned API",
            "completed": false
          },
          {
            "task": "Deprecate an older version",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "api-versioning",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Stripe API Versioning",
          "REST API Versioning Best Practices"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "API Versioning Strategies: Choosing the Least Painful Path",
          "gist": "Explain different versioning strategies and their tradeoffs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T25-ST02",
        "title": "Backward compatibility",
        "details": "Understand backward compatibility as the ability for existing clients to continue working without changes.",
        "masteryCriteria": [
          {
            "criteria": "Can define backward compatibility",
            "mastered": false
          },
          {
            "criteria": "Can design additive changes",
            "mastered": false
          },
          {
            "criteria": "Can avoid breaking consumers",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add backward-compatible changes",
            "completed": false
          },
          {
            "task": "Validate existing clients",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "backward-compatibility",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "API Compatibility Guidelines",
          "Google API Design Guide"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Backward Compatibility: Respecting Existing API Consumers",
          "gist": "Explain why backward compatibility is critical for public APIs.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T25-ST03",
        "title": "Breaking change avoidance",
        "details": "Learn how to identify and avoid breaking changes that disrupt existing API consumers.",
        "masteryCriteria": [
          {
            "criteria": "Can identify breaking changes",
            "mastered": false
          },
          {
            "criteria": "Can refactor APIs safely",
            "mastered": false
          },
          {
            "criteria": "Can plan deprecations",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Audit an API for breaking changes",
            "completed": false
          },
          {
            "task": "Design a non-breaking alternative",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "breaking-change-avoidance",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Semantic Versioning",
          "REST API Change Management"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Breaking Change Avoidance: Designing APIs That Don't Hurt Users",
          "gist": "Explain common breaking changes and how to avoid them.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T25-ST04",
        "title": "OpenAPI specs",
        "details": "Understand OpenAPI specifications as a formal contract for documenting and validating APIs.",
        "masteryCriteria": [
          {
            "criteria": "Can write OpenAPI specs",
            "mastered": false
          },
          {
            "criteria": "Can validate APIs against specs",
            "mastered": false
          },
          {
            "criteria": "Can generate clients or docs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write OpenAPI specs",
            "completed": false
          },
          {
            "task": "Generate API documentation",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "openapi-specs",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OpenAPI Specification",
          "Swagger Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "OpenAPI Specs: Turning APIs Into Formal Contracts",
          "gist": "Explain how OpenAPI improves API clarity and reliability.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T25-ST05",
        "title": "Schema evolution",
        "details": "Understand how API schemas evolve over time without breaking consumers.",
        "masteryCriteria": [
          {
            "criteria": "Can evolve schemas safely",
            "mastered": false
          },
          {
            "criteria": "Can add fields without breaking clients",
            "mastered": false
          },
          {
            "criteria": "Can manage deprecated fields",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Evolve an API schema",
            "completed": false
          },
          {
            "task": "Handle deprecated fields",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "schema-evolution",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Schema Evolution Patterns",
          "Avro / Protobuf Evolution Concepts"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Schema Evolution: Changing APIs Without Breaking Them",
          "gist": "Explain safe schema evolution patterns.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T25-ST06",
        "title": "Consumer-driven contracts",
        "details": "Understand consumer-driven contract testing to ensure providers meet consumer expectations.",
        "masteryCriteria": [
          {
            "criteria": "Can explain contract testing",
            "mastered": false
          },
          {
            "criteria": "Can write consumer-driven contracts",
            "mastered": false
          },
          {
            "criteria": "Can detect breaking changes early",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create contract tests",
            "completed": false
          },
          {
            "task": "Validate provider changes",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "consumer-driven-contracts",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Pact Documentation",
          "Microservices Contract Testing"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Consumer-Driven Contracts: Preventing API Breakage Early",
          "gist": "Explain how contract testing protects API consumers.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T25-ST07",
        "title": "GraphQL pros/cons (even if you don't use it)",
        "details": "Understand GraphQL strengths and weaknesses compared to REST, even if GraphQL is not used in your stack.",
        "masteryCriteria": [
          {
            "criteria": "Can explain GraphQL pros and cons",
            "mastered": false
          },
          {
            "criteria": "Can compare GraphQL to REST",
            "mastered": false
          },
          {
            "criteria": "Can decide when not to use GraphQL",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze GraphQL vs REST use cases",
            "completed": false
          },
          {
            "task": "Design a simple GraphQL schema",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "graphql-pros-cons",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "GraphQL Official Documentation",
          "REST vs GraphQL Comparisons"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "GraphQL Pros and Cons: When It Helps and When It Hurts",
          "gist": "Explain GraphQL tradeoffs honestly.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T25-ST08",
        "title": "BFF (Backend for Frontend) pattern",
        "details": "Understand the Backend for Frontend pattern and how it tailors APIs to specific client needs.",
        "masteryCriteria": [
          {
            "criteria": "Can explain BFF pattern",
            "mastered": false
          },
          {
            "criteria": "Can design client-specific APIs",
            "mastered": false
          },
          {
            "criteria": "Can avoid BFF over-fragmentation",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Design a BFF layer",
            "completed": false
          },
          {
            "task": "Route client requests through BFF",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "bff-pattern",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Sam Newman - BFF Pattern",
          "Microservices API Patterns"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Backend for Frontend: Designing APIs for Client Needs",
          "gist": "Explain when and why BFFs are useful.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T25-ST09",
        "title": "Pagination correctness",
        "details": "Understand correct pagination strategies that avoid missing or duplicating data at scale.",
        "masteryCriteria": [
          {
            "criteria": "Can design correct pagination",
            "mastered": false
          },
          {
            "criteria": "Can avoid offset pitfalls",
            "mastered": false
          },
          {
            "criteria": "Can handle large datasets",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement cursor-based pagination",
            "completed": false
          },
          {
            "task": "Test pagination edge cases",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "pagination-correctness",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Cursor Pagination Patterns",
          "Stripe Pagination Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Pagination Correctness: Why Offset Pagination Breaks at Scale",
          "gist": "Explain pagination pitfalls and safer approaches.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T25-ST10",
        "title": "Filtering at scale",
        "details": "Understand how filtering affects performance and correctness when datasets grow large.",
        "masteryCriteria": [
          {
            "criteria": "Can design scalable filtering",
            "mastered": false
          },
          {
            "criteria": "Can push filtering to the right layer",
            "mastered": false
          },
          {
            "criteria": "Can avoid expensive queries",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement scalable filtering",
            "completed": false
          },
          {
            "task": "Measure query performance",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "filtering-at-scale",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Database Query Optimization",
          "API Filtering Best Practices"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Filtering at Scale: Designing APIs That Don't Melt Databases",
          "gist": "Explain filtering strategies that scale with data size.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T26",
    "title": "Frontend Architecture at Scale",
    "parentTopic": "T07",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic focuses on structuring large frontend codebases so they remain understandable, scalable, and maintainable over time. Mastery means you can enforce boundaries, manage shared UI systems, prevent coupling, and scale teams without frontend entropy.",
    "projectsCoveredIn": [
      "P2",
      "P4",
      "P6"
    ],
    "references": [
      "Feature-Sliced Design",
      "Google Frontend Architecture Talks",
      "Micro-Frontends - ThoughtWorks"
    ],
    "subTasks": [
      {
        "id": "T26-ST01",
        "title": "Feature-based folder structures",
        "details": "Understand organizing frontend code by features instead of technical layers to improve cohesion and scalability.",
        "masteryCriteria": [
          {
            "criteria": "Can explain feature-based structure",
            "mastered": false
          },
          {
            "criteria": "Can refactor layer-based folders",
            "mastered": false
          },
          {
            "criteria": "Can reduce cross-feature coupling",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Refactor a project to feature-based structure",
            "completed": false
          },
          {
            "task": "Enforce feature boundaries",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "feature-based-structure",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Feature-Sliced Design Docs",
          "Frontend Folder Structure Patterns"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Feature-Based Folder Structures: Scaling Frontend Codebases",
          "gist": "Explain why organizing by features scales better than organizing by file type.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T26-ST02",
        "title": "Dependency direction rules",
        "details": "Learn to enforce dependency direction so higher-level features do not leak into lower-level modules.",
        "masteryCriteria": [
          {
            "criteria": "Can define dependency rules",
            "mastered": false
          },
          {
            "criteria": "Can detect circular dependencies",
            "mastered": false
          },
          {
            "criteria": "Can enforce boundaries automatically",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Define dependency rules",
            "completed": false
          },
          {
            "task": "Add lint rules for violations",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "dependency-direction",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Clean Architecture Principles",
          "ESLint Dependency Rules"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Dependency Direction Rules: Preventing Frontend Spaghetti",
          "gist": "Explain how dependency rules keep large frontend systems sane.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T26-ST03",
        "title": "UI state isolation",
        "details": "Understand isolating UI state to prevent global state sprawl and unintended coupling.",
        "masteryCriteria": [
          {
            "criteria": "Can identify over-globalized state",
            "mastered": false
          },
          {
            "criteria": "Can isolate UI state correctly",
            "mastered": false
          },
          {
            "criteria": "Can reduce unnecessary re-renders",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Refactor global state to local state",
            "completed": false
          },
          {
            "task": "Isolate feature-level state",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "ui-state-isolation",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React State Management Guides",
          "Zustand Best Practices"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "UI State Isolation: Keeping Frontend State Manageable",
          "gist": "Explain why not all state belongs in global stores.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T26-ST04",
        "title": "Design system governance",
        "details": "Understand how design systems are governed, versioned, and evolved across teams.",
        "masteryCriteria": [
          {
            "criteria": "Can define governance models",
            "mastered": false
          },
          {
            "criteria": "Can manage breaking changes",
            "mastered": false
          },
          {
            "criteria": "Can balance flexibility and consistency",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Define design system contribution rules",
            "completed": false
          },
          {
            "task": "Version a design system",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "design-system-governance",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Design Systems Handbook",
          "Shopify Polaris Governance"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Design System Governance: Scaling UI Consistency",
          "gist": "Explain how governance keeps design systems usable at scale.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T26-ST05",
        "title": "Shared vs local components",
        "details": "Learn how to decide whether components should be shared globally or kept local to a feature.",
        "masteryCriteria": [
          {
            "criteria": "Can classify component scope",
            "mastered": false
          },
          {
            "criteria": "Can avoid premature abstraction",
            "mastered": false
          },
          {
            "criteria": "Can prevent shared component bloat",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Audit shared components",
            "completed": false
          },
          {
            "task": "Move overly specific components local",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "shared-vs-local-components",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Component Design Principles",
          "Frontend Architecture Case Studies"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Shared vs Local Components: Avoiding UI Coupling",
          "gist": "Explain how over-sharing components slows teams down.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T26-ST06",
        "title": "Micro-frontends (when NOT to use them)",
        "details": "Understand micro-frontend architectures, their complexity, and scenarios where they introduce more harm than benefit.",
        "masteryCriteria": [
          {
            "criteria": "Can explain micro-frontend tradeoffs",
            "mastered": false
          },
          {
            "criteria": "Can identify misuse scenarios",
            "mastered": false
          },
          {
            "criteria": "Can justify not using micro-frontends",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Evaluate micro-frontend proposals",
            "completed": false
          },
          {
            "task": "Document reasons against adoption",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "micro-frontends",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Micro-Frontends - ThoughtWorks",
          "Frontend Architecture Talks"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Micro-Frontends: Knowing When to Say No",
          "gist": "Explain why micro-frontends are often overused.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T26-ST07",
        "title": "Module boundaries",
        "details": "Understand defining and enforcing module boundaries to limit coupling and improve maintainability.",
        "masteryCriteria": [
          {
            "criteria": "Can define module boundaries",
            "mastered": false
          },
          {
            "criteria": "Can enforce boundaries",
            "mastered": false
          },
          {
            "criteria": "Can prevent cross-module leaks",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Define modules explicitly",
            "completed": false
          },
          {
            "task": "Add boundary enforcement",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "module-boundaries",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Modular Frontend Architecture",
          "Clean Architecture"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Module Boundaries: The Backbone of Frontend Architecture",
          "gist": "Explain how clear boundaries prevent architectural decay.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T26-ST08",
        "title": "Build-time vs runtime config",
        "details": "Understand the difference between build-time and runtime configuration and how it affects deployments.",
        "masteryCriteria": [
          {
            "criteria": "Can explain config timing",
            "mastered": false
          },
          {
            "criteria": "Can choose correct config strategy",
            "mastered": false
          },
          {
            "criteria": "Can avoid rebuild-only changes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Move config to runtime",
            "completed": false
          },
          {
            "task": "Audit config usage",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "build-vs-runtime-config",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "12-Factor App - Config",
          "Frontend Config Patterns"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Build-Time vs Runtime Config: Avoiding Frontend Redeploys",
          "gist": "Explain why runtime config matters for frontend systems.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T26-ST09",
        "title": "Code ownership models",
        "details": "Understand code ownership as a way to scale teams and maintain quality across large codebases.",
        "masteryCriteria": [
          {
            "criteria": "Can define ownership boundaries",
            "mastered": false
          },
          {
            "criteria": "Can assign clear responsibility",
            "mastered": false
          },
          {
            "criteria": "Can reduce review bottlenecks",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Define code owners",
            "completed": false
          },
          {
            "task": "Set up ownership enforcement",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "code-ownership",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "GitHub CODEOWNERS",
          "Google Engineering Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Code Ownership Models: Scaling Frontend Teams",
          "gist": "Explain how ownership improves accountability and velocity.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T27",
    "title": "Memory & Resource Leak Hunting (Elite Skill)",
    "parentTopic": "T21",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic covers diagnosing and fixing memory and resource leaks in production systems. Mastery means you can use profiling tools, interpret snapshots, identify retention paths, and stop slow-burning failures that crash systems over time.",
    "projectsCoveredIn": [
      "P2",
      "P5",
      "P6"
    ],
    "references": [
      "Chrome DevTools Memory Guide",
      "Node.js Diagnostics Documentation",
      "Linux Process and Memory Internals"
    ],
    "subTasks": [
      {
        "id": "T27-ST01",
        "title": "Heap snapshot analysis",
        "details": "Learn how to capture and analyze heap snapshots to understand memory usage and growth over time.",
        "masteryCriteria": [
          {
            "criteria": "Can capture heap snapshots",
            "mastered": false
          },
          {
            "criteria": "Can compare snapshots over time",
            "mastered": false
          },
          {
            "criteria": "Can identify suspicious growth",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Capture heap snapshots",
            "completed": false
          },
          {
            "task": "Analyze memory growth patterns",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "heap-snapshot-analysis",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Chrome DevTools Heap Snapshots",
          "Node.js Heap Profiling"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Heap Snapshot Analysis: Seeing Memory for What It Is",
          "gist": "Explain how heap snapshots reveal memory usage and leaks.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T27-ST02",
        "title": "Retained object trees",
        "details": "Understand retained object trees to identify why objects remain in memory and what is keeping them alive.",
        "masteryCriteria": [
          {
            "criteria": "Can read retained object trees",
            "mastered": false
          },
          {
            "criteria": "Can trace retention paths",
            "mastered": false
          },
          {
            "criteria": "Can identify root causes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze retained object trees",
            "completed": false
          },
          {
            "task": "Identify retention chains",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "retained-object-trees",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Chrome Memory Retainers",
          "V8 Garbage Collection Concepts"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Retained Object Trees: Finding What Keeps Memory Alive",
          "gist": "Explain how retention paths expose memory leaks.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T27-ST03",
        "title": "Event listener leaks",
        "details": "Understand how unremoved event listeners prevent garbage collection and cause memory leaks.",
        "masteryCriteria": [
          {
            "criteria": "Can identify leaked listeners",
            "mastered": false
          },
          {
            "criteria": "Can clean up listeners correctly",
            "mastered": false
          },
          {
            "criteria": "Can avoid repeated registrations",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Audit event listeners",
            "completed": false
          },
          {
            "task": "Fix leaked listeners",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "event-listener-leaks",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN Event Listener Memory",
          "Frontend Memory Leak Patterns"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Event Listener Leaks: The Silent Memory Killers",
          "gist": "Explain how forgotten listeners keep objects alive.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T27-ST04",
        "title": "Closure leaks",
        "details": "Understand how closures can capture references unintentionally and prevent memory from being freed.",
        "masteryCriteria": [
          {
            "criteria": "Can explain closure retention",
            "mastered": false
          },
          {
            "criteria": "Can identify leaked closures",
            "mastered": false
          },
          {
            "criteria": "Can refactor to release memory",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Inspect closures in heap snapshots",
            "completed": false
          },
          {
            "task": "Refactor leaking closures",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "closure-leaks",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "JavaScript Closures Explained",
          "V8 Memory Retention"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Closure Leaks: When Scope Becomes a Memory Trap",
          "gist": "Explain how closures cause hidden memory leaks.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T27-ST05",
        "title": "Detached DOM nodes",
        "details": "Understand detached DOM nodes and how references to removed elements cause frontend memory leaks.",
        "masteryCriteria": [
          {
            "criteria": "Can identify detached DOM nodes",
            "mastered": false
          },
          {
            "criteria": "Can trace references",
            "mastered": false
          },
          {
            "criteria": "Can ensure proper cleanup",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Detect detached DOM nodes",
            "completed": false
          },
          {
            "task": "Fix DOM cleanup issues",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "detached-dom-nodes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Chrome DevTools Detached DOM",
          "Frontend Performance Guides"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Detached DOM Nodes: Leaks You Can't See",
          "gist": "Explain how DOM nodes leak memory after removal.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T27-ST06",
        "title": "Long-lived references",
        "details": "Understand how long-lived references (globals, singletons, caches) prevent garbage collection.",
        "masteryCriteria": [
          {
            "criteria": "Can identify long-lived references",
            "mastered": false
          },
          {
            "criteria": "Can manage object lifetimes",
            "mastered": false
          },
          {
            "criteria": "Can avoid accidental global retention",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Audit globals and caches",
            "completed": false
          },
          {
            "task": "Refactor long-lived references",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "long-lived-references",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "JavaScript Memory Management",
          "Node.js Global Scope"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Long-Lived References: Why Memory Never Gets Freed",
          "gist": "Explain how globals and caches cause leaks.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T27-ST07",
        "title": "Node memory profiling",
        "details": "Learn to profile memory usage in Node.js applications using built-in and external tools.",
        "masteryCriteria": [
          {
            "criteria": "Can profile Node memory",
            "mastered": false
          },
          {
            "criteria": "Can identify heap growth",
            "mastered": false
          },
          {
            "criteria": "Can correlate memory with load",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Run Node memory profilers",
            "completed": false
          },
          {
            "task": "Analyze production-like workloads",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "node-memory-profiling",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Node.js --inspect and --heap-prof",
          "Clinic.js Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Node Memory Profiling: Debugging Leaks in Production",
          "gist": "Explain how to profile Node.js memory safely.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T27-ST08",
        "title": "File descriptor leaks",
        "details": "Understand how failing to close files or sockets exhausts file descriptors and crashes servers.",
        "masteryCriteria": [
          {
            "criteria": "Can detect FD leaks",
            "mastered": false
          },
          {
            "criteria": "Can inspect open descriptors",
            "mastered": false
          },
          {
            "criteria": "Can fix leaking I/O",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Inspect open file descriptors",
            "completed": false
          },
          {
            "task": "Fix FD leaks",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "fd-leaks",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Linux lsof and ulimit",
          "Node.js fs and net Cleanup"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "File Descriptor Leaks: Running Out of Invisible Resources",
          "gist": "Explain how FD leaks bring down services.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T27-ST09",
        "title": "Zombie processes",
        "details": "Understand zombie processes, how they occur, and how improper process management leads to resource exhaustion.",
        "masteryCriteria": [
          {
            "criteria": "Can explain zombie processes",
            "mastered": false
          },
          {
            "criteria": "Can detect zombies",
            "mastered": false
          },
          {
            "criteria": "Can prevent orphaned processes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Identify zombie processes",
            "completed": false
          },
          {
            "task": "Fix improper child process handling",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "zombie-processes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Linux Process States",
          "Node.js Child Process Docs"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Zombie Processes: The Dead That Still Consume Resources",
          "gist": "Explain how zombie processes appear and how to prevent them.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T28",
    "title": "Observability Engineering (Not Just Logging)",
    "parentTopic": "T13",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic focuses on building systems that can explain themselves in production. Mastery means you can instrument systems for insight, avoid noise, define reliability targets, and learn systematically from failures instead of reacting blindly.",
    "projectsCoveredIn": [
      "P2",
      "P5",
      "P6"
    ],
    "references": [
      "Google SRE Book - Monitoring & Alerting",
      "Observability Engineering - Charity Majors",
      "OpenTelemetry Documentation"
    ],
    "subTasks": [
      {
        "id": "T28-ST01",
        "title": "Structured logging",
        "details": "Understand structured logging as emitting machine-parsable logs with consistent fields instead of free-form text.",
        "masteryCriteria": [
          {
            "criteria": "Can design structured log schemas",
            "mastered": false
          },
          {
            "criteria": "Can avoid unstructured log spam",
            "mastered": false
          },
          {
            "criteria": "Can query logs effectively",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Convert logs to structured format",
            "completed": false
          },
          {
            "task": "Query logs by fields",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "structured-logging",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google Cloud Structured Logging",
          "Elastic Common Schema"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Structured Logging: Making Logs Queryable, Not Just Readable",
          "gist": "Explain why structured logs outperform plain text logs in production.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T28-ST02",
        "title": "Correlation IDs",
        "details": "Understand correlation IDs as identifiers that link logs, metrics, and traces across distributed systems.",
        "masteryCriteria": [
          {
            "criteria": "Can propagate correlation IDs",
            "mastered": false
          },
          {
            "criteria": "Can trace requests end-to-end",
            "mastered": false
          },
          {
            "criteria": "Can debug cross-service issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add correlation IDs to requests",
            "completed": false
          },
          {
            "task": "Trace multi-service flows",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "correlation-ids",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OpenTelemetry Context Propagation",
          "Distributed Tracing Concepts"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Correlation IDs: Following a Request Through Chaos",
          "gist": "Explain how correlation IDs make distributed debugging possible.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T28-ST03",
        "title": "Distributed tracing",
        "details": "Understand distributed tracing to visualize request flows, latencies, and failures across services.",
        "masteryCriteria": [
          {
            "criteria": "Can instrument distributed traces",
            "mastered": false
          },
          {
            "criteria": "Can analyze trace waterfalls",
            "mastered": false
          },
          {
            "criteria": "Can identify latency bottlenecks",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add tracing instrumentation",
            "completed": false
          },
          {
            "task": "Analyze slow traces",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "distributed-tracing",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OpenTelemetry Tracing",
          "Jaeger Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Distributed Tracing: Seeing the Shape of Requests",
          "gist": "Explain how tracing reveals system behavior under load.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T28-ST04",
        "title": "RED & USE metrics",
        "details": "Understand RED (Rate, Errors, Duration) and USE (Utilization, Saturation, Errors) metrics as frameworks for monitoring.",
        "masteryCriteria": [
          {
            "criteria": "Can explain RED and USE",
            "mastered": false
          },
          {
            "criteria": "Can map metrics to system health",
            "mastered": false
          },
          {
            "criteria": "Can avoid vanity metrics",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Define RED metrics for services",
            "completed": false
          },
          {
            "task": "Define USE metrics for resources",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "red-use-metrics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Monitoring",
          "Brendan Gregg - USE Method"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "RED and USE Metrics: Monitoring That Actually Works",
          "gist": "Explain why RED and USE beat random metric dashboards.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T28-ST05",
        "title": "Cardinality control",
        "details": "Understand metric and log cardinality and why uncontrolled labels can break observability systems.",
        "masteryCriteria": [
          {
            "criteria": "Can explain cardinality",
            "mastered": false
          },
          {
            "criteria": "Can design low-cardinality labels",
            "mastered": false
          },
          {
            "criteria": "Can prevent metric explosions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Audit metrics for high cardinality",
            "completed": false
          },
          {
            "task": "Refactor labels safely",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "cardinality-control",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Prometheus Cardinality Best Practices",
          "Observability Cost Control Guides"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Cardinality Control: Preventing Observability Systems From Melting",
          "gist": "Explain why high-cardinality metrics are dangerous.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T28-ST06",
        "title": "Log sampling",
        "details": "Understand log sampling techniques to reduce volume while preserving signal.",
        "masteryCriteria": [
          {
            "criteria": "Can explain sampling strategies",
            "mastered": false
          },
          {
            "criteria": "Can balance cost and visibility",
            "mastered": false
          },
          {
            "criteria": "Can avoid losing critical events",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement log sampling",
            "completed": false
          },
          {
            "task": "Compare sampled vs full logs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "log-sampling",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Honeycomb Log Sampling Guides",
          "OpenTelemetry Sampling"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Log Sampling: Reducing Noise Without Losing Signal",
          "gist": "Explain how sampling keeps observability affordable.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T28-ST07",
        "title": "Alert fatigue prevention",
        "details": "Understand how poor alerting creates noise and how to design actionable alerts.",
        "masteryCriteria": [
          {
            "criteria": "Can design actionable alerts",
            "mastered": false
          },
          {
            "criteria": "Can reduce alert noise",
            "mastered": false
          },
          {
            "criteria": "Can prevent pager overload",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Audit existing alerts",
            "completed": false
          },
          {
            "task": "Reduce noisy alerts",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "alert-fatigue",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Alerting Philosophy",
          "PagerDuty Alert Best Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Alert Fatigue: When Monitoring Becomes the Problem",
          "gist": "Explain how bad alerts harm reliability instead of helping it.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T28-ST08",
        "title": "SLOs vs SLAs",
        "details": "Understand the difference between Service Level Objectives and Service Level Agreements and why engineers should focus on SLOs.",
        "masteryCriteria": [
          {
            "criteria": "Can explain SLOs vs SLAs",
            "mastered": false
          },
          {
            "criteria": "Can define meaningful SLOs",
            "mastered": false
          },
          {
            "criteria": "Can avoid SLA-driven engineering",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Define SLOs for a service",
            "completed": false
          },
          {
            "task": "Map SLOs to metrics",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "slos-vs-slas",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - SLOs",
          "Error Budget Concepts"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "SLOs vs SLAs: Engineering for Reliability, Not Contracts",
          "gist": "Explain why SLOs guide better engineering decisions.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T28-ST09",
        "title": "Error budgets",
        "details": "Understand error budgets as a mechanism to balance reliability and velocity.",
        "masteryCriteria": [
          {
            "criteria": "Can explain error budgets",
            "mastered": false
          },
          {
            "criteria": "Can enforce error budget policies",
            "mastered": false
          },
          {
            "criteria": "Can stop releases when budgets are exhausted",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Calculate error budgets",
            "completed": false
          },
          {
            "task": "Apply release gating",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "error-budgets",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Error Budgets",
          "Reliability Engineering Guides"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Error Budgets: Turning Reliability Into a Feature",
          "gist": "Explain how error budgets align engineering and business goals.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T28-ST10",
        "title": "Postmortem analysis",
        "details": "Learn how to conduct blameless postmortems that lead to real system improvements.",
        "masteryCriteria": [
          {
            "criteria": "Can write blameless postmortems",
            "mastered": false
          },
          {
            "criteria": "Can identify systemic causes",
            "mastered": false
          },
          {
            "criteria": "Can create actionable follow-ups",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write a postmortem",
            "completed": false
          },
          {
            "task": "Track corrective actions",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "postmortems",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Postmortems",
          "Incident Review Best Practices"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Postmortem Analysis: Learning Faster Than Failure",
          "gist": "Explain how postmortems improve systems instead of assigning blame.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T29",
    "title": "Build & Release Engineering",
    "parentTopic": "T16",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic focuses on making software releases safe, repeatable, and boring. Mastery means you can produce deterministic builds, design resilient release pipelines, deploy without downtime, and recover safely when things go wrong.",
    "projectsCoveredIn": [
      "P2",
      "P5",
      "P6"
    ],
    "references": [
      "Google SRE Book - Release Engineering",
      "Continuous Delivery - Jez Humble",
      "AWS Builders Library - Deployment Safety"
    ],
    "subTasks": [
      {
        "id": "T29-ST01",
        "title": "Deterministic builds",
        "details": "Understand deterministic builds as producing identical artifacts from the same source every time.",
        "masteryCriteria": [
          {
            "criteria": "Can define deterministic builds",
            "mastered": false
          },
          {
            "criteria": "Can eliminate non-determinism",
            "mastered": false
          },
          {
            "criteria": "Can verify build outputs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create deterministic build configs",
            "completed": false
          },
          {
            "task": "Compare build artifacts across runs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "deterministic-builds",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Reproducible Builds Project",
          "Google Release Engineering"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Deterministic Builds: Why the Same Code Must Produce the Same Artifact",
          "gist": "Explain why non-deterministic builds break trust in releases.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T29-ST02",
        "title": "Build reproducibility",
        "details": "Understand build reproducibility as the ability to rebuild identical artifacts later, even across environments.",
        "masteryCriteria": [
          {
            "criteria": "Can reproduce past builds",
            "mastered": false
          },
          {
            "criteria": "Can pin dependencies and tooling",
            "mastered": false
          },
          {
            "criteria": "Can detect drift",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Rebuild older releases",
            "completed": false
          },
          {
            "task": "Lock dependency versions",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "build-reproducibility",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Nix Reproducible Builds",
          "Docker Image Reproducibility"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Build Reproducibility: Recreating the Past on Demand",
          "gist": "Explain why reproducibility matters for debugging and security.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T29-ST03",
        "title": "Artifact storage",
        "details": "Understand artifact storage as managing immutable build outputs separate from source code.",
        "masteryCriteria": [
          {
            "criteria": "Can define artifact lifecycles",
            "mastered": false
          },
          {
            "criteria": "Can manage artifact repositories",
            "mastered": false
          },
          {
            "criteria": "Can ensure immutability",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Store artifacts centrally",
            "completed": false
          },
          {
            "task": "Version and tag artifacts",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "artifact-storage",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "JFrog Artifactory Docs",
          "AWS ECR Best Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Artifact Storage: Treating Builds as First-Class Outputs",
          "gist": "Explain why artifacts should be immutable and centrally stored.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T29-ST04",
        "title": "Release pipelines",
        "details": "Understand release pipelines as automated paths that move artifacts from build to production.",
        "masteryCriteria": [
          {
            "criteria": "Can design multi-stage pipelines",
            "mastered": false
          },
          {
            "criteria": "Can add safety gates",
            "mastered": false
          },
          {
            "criteria": "Can observe pipeline health",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Design a release pipeline",
            "completed": false
          },
          {
            "task": "Add automated checks",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "release-pipelines",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "GitHub Actions Pipelines",
          "GitLab CI/CD Pipelines"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Release Pipelines: Turning Builds Into Production Safely",
          "gist": "Explain how pipelines reduce human error in releases.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T29-ST05",
        "title": "Feature flags",
        "details": "Understand feature flags as runtime switches that decouple deployment from release.",
        "masteryCriteria": [
          {
            "criteria": "Can explain feature flag benefits",
            "mastered": false
          },
          {
            "criteria": "Can avoid flag debt",
            "mastered": false
          },
          {
            "criteria": "Can control exposure safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement feature flags",
            "completed": false
          },
          {
            "task": "Clean up stale flags",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "feature-flags",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "LaunchDarkly Feature Flags",
          "Feature Flag Best Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Feature Flags: Shipping Code Without Releasing It",
          "gist": "Explain how feature flags enable safer releases.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T29-ST06",
        "title": "Blue-green deployments",
        "details": "Understand blue-green deployments as running two production environments to enable instant cutovers.",
        "masteryCriteria": [
          {
            "criteria": "Can explain blue-green deployments",
            "mastered": false
          },
          {
            "criteria": "Can perform safe cutovers",
            "mastered": false
          },
          {
            "criteria": "Can validate new versions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Set up blue-green deployment",
            "completed": false
          },
          {
            "task": "Test rollback scenarios",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "blue-green-deployments",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS Blue/Green Deployments",
          "Kubernetes Deployment Strategies"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Blue-Green Deployments: Zero-Risk Production Switches",
          "gist": "Explain how blue-green deployments reduce downtime.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T29-ST07",
        "title": "Canary releases",
        "details": "Understand canary releases as gradually exposing changes to a subset of users.",
        "masteryCriteria": [
          {
            "criteria": "Can design canary strategies",
            "mastered": false
          },
          {
            "criteria": "Can monitor canary health",
            "mastered": false
          },
          {
            "criteria": "Can abort failing canaries",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Deploy a canary release",
            "completed": false
          },
          {
            "task": "Monitor error rates",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "canary-releases",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Canarying",
          "Progressive Delivery"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Canary Releases: Letting a Few Users Test First",
          "gist": "Explain how canaries reduce blast radius.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T29-ST08",
        "title": "Schema migration safety",
        "details": "Understand how database schema changes interact with rolling deployments.",
        "masteryCriteria": [
          {
            "criteria": "Can design backward-compatible migrations",
            "mastered": false
          },
          {
            "criteria": "Can avoid breaking live traffic",
            "mastered": false
          },
          {
            "criteria": "Can coordinate app and schema changes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Perform safe schema migrations",
            "completed": false
          },
          {
            "task": "Test rolling deploys with migrations",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "schema-migration-safety",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Zero-Downtime Migration Patterns",
          "Liquibase / Flyway Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Schema Migration Safety: Changing Databases Without Downtime",
          "gist": "Explain safe patterns for evolving schemas in production.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T29-ST09",
        "title": "Zero-downtime deploys",
        "details": "Understand deployment techniques that avoid service interruption during releases.",
        "masteryCriteria": [
          {
            "criteria": "Can deploy without downtime",
            "mastered": false
          },
          {
            "criteria": "Can handle in-flight requests",
            "mastered": false
          },
          {
            "criteria": "Can verify availability",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Deploy with zero downtime",
            "completed": false
          },
          {
            "task": "Test live traffic behavior",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "zero-downtime-deploys",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Kubernetes Rolling Updates",
          "NGINX Graceful Reloads"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Zero-Downtime Deploys: Keeping Services Available While Shipping",
          "gist": "Explain how to deploy without interrupting users.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T29-ST10",
        "title": "Roll-forward vs rollback",
        "details": "Understand the tradeoff between rolling forward with fixes and rolling back to previous versions.",
        "masteryCriteria": [
          {
            "criteria": "Can explain roll-forward vs rollback",
            "mastered": false
          },
          {
            "criteria": "Can choose correct recovery strategy",
            "mastered": false
          },
          {
            "criteria": "Can avoid repeated failures",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Simulate failure recovery",
            "completed": false
          },
          {
            "task": "Document recovery decisions",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "roll-forward-vs-rollback",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Rollbacks",
          "Release Failure Recovery Guides"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Roll-Forward vs Rollback: Choosing How to Recover From Failed Releases",
          "gist": "Explain why roll-forward is often safer than rollback.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T30",
    "title": "Advanced Security Engineering",
    "parentTopic": "T14",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic focuses on thinking like an attacker and engineering systems that survive real-world threats. Mastery means you can model threats, reduce attack surface, design resilient auth/session systems, and manage security risk across the supply chain.",
    "projectsCoveredIn": [
      "P5",
      "P6"
    ],
    "references": [
      "OWASP Top 10",
      "Threat Modeling - Adam Shostack",
      "Google Security Engineering Book"
    ],
    "subTasks": [
      {
        "id": "T30-ST01",
        "title": "Threat modeling",
        "details": "Learn to systematically identify threats, assets, trust boundaries, and mitigations using structured models.",
        "masteryCriteria": [
          {
            "criteria": "Can identify assets and trust boundaries",
            "mastered": false
          },
          {
            "criteria": "Can enumerate realistic threats",
            "mastered": false
          },
          {
            "criteria": "Can propose mitigations",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create a threat model for an app",
            "completed": false
          },
          {
            "task": "Review threats with peers",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "threat-model",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "STRIDE Threat Model",
          "OWASP Threat Modeling"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Threat Modeling: Designing Systems With Attackers in Mind",
          "gist": "Explain how threat modeling prevents entire classes of vulnerabilities.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T30-ST02",
        "title": "Attack surface analysis",
        "details": "Understand how to inventory and minimize exposed endpoints, permissions, and integrations.",
        "masteryCriteria": [
          {
            "criteria": "Can define attack surface",
            "mastered": false
          },
          {
            "criteria": "Can identify unnecessary exposure",
            "mastered": false
          },
          {
            "criteria": "Can reduce surface area",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Map attack surface",
            "completed": false
          },
          {
            "task": "Disable unused endpoints",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "attack-surface",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OWASP Attack Surface Analysis",
          "Google Security Best Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Attack Surface Analysis: Reducing What Attackers Can Touch",
          "gist": "Explain why smaller attack surfaces are safer.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T30-ST03",
        "title": "Token rotation",
        "details": "Understand rotating credentials and tokens to limit blast radius after compromise.",
        "masteryCriteria": [
          {
            "criteria": "Can explain token rotation",
            "mastered": false
          },
          {
            "criteria": "Can design rotation flows",
            "mastered": false
          },
          {
            "criteria": "Can avoid breaking sessions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement token rotation",
            "completed": false
          },
          {
            "task": "Test rotation under load",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "token-rotation",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OAuth Token Rotation",
          "AWS IAM Credential Rotation"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Token Rotation: Limiting the Damage of Compromise",
          "gist": "Explain why static tokens are dangerous.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T30-ST04",
        "title": "Session fixation",
        "details": "Understand session fixation attacks and how improper session handling enables account takeover.",
        "masteryCriteria": [
          {
            "criteria": "Can explain session fixation",
            "mastered": false
          },
          {
            "criteria": "Can rotate session identifiers",
            "mastered": false
          },
          {
            "criteria": "Can secure auth flows",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Audit session handling",
            "completed": false
          },
          {
            "task": "Fix fixation vulnerabilities",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "session-fixation",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OWASP Session Fixation",
          "Web Session Security"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Session Fixation: A Subtle Path to Account Takeover",
          "gist": "Explain how attackers exploit fixed sessions.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T30-ST05",
        "title": "Replay attacks",
        "details": "Understand replay attacks where intercepted requests are resent to perform unauthorized actions.",
        "masteryCriteria": [
          {
            "criteria": "Can explain replay attacks",
            "mastered": false
          },
          {
            "criteria": "Can add nonce or timestamp protections",
            "mastered": false
          },
          {
            "criteria": "Can design replay-resistant APIs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Simulate replay attacks",
            "completed": false
          },
          {
            "task": "Add replay protection",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "replay-attacks",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OAuth Replay Protection",
          "API Security Best Practices"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Replay Attacks: When Old Requests Become New Threats",
          "gist": "Explain how replay attacks work and how to stop them.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T30-ST06",
        "title": "Rate limit evasion",
        "details": "Understand how attackers bypass naive rate limits and how to design resilient controls.",
        "masteryCriteria": [
          {
            "criteria": "Can explain evasion techniques",
            "mastered": false
          },
          {
            "criteria": "Can design robust rate limits",
            "mastered": false
          },
          {
            "criteria": "Can detect abuse patterns",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Test rate limit evasion",
            "completed": false
          },
          {
            "task": "Harden rate limiting rules",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "rate-limit-evasion",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OWASP API Security - Rate Limiting",
          "Cloudflare Rate Limiting"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Rate Limit Evasion: Why Simple Limits Fail",
          "gist": "Explain how attackers bypass basic rate limiting.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T30-ST07",
        "title": "Secrets rotation",
        "details": "Understand rotating secrets automatically to reduce exposure windows and human error.",
        "masteryCriteria": [
          {
            "criteria": "Can automate secret rotation",
            "mastered": false
          },
          {
            "criteria": "Can avoid hard-coded secrets",
            "mastered": false
          },
          {
            "criteria": "Can handle rotation safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Set up secret rotation",
            "completed": false
          },
          {
            "task": "Audit secret usage",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "secrets-rotation",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS Secrets Manager",
          "HashiCorp Vault Rotation"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Secrets Rotation: Designing for Inevitable Leaks",
          "gist": "Explain why secrets must rotate continuously.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T30-ST08",
        "title": "Supply-chain attacks",
        "details": "Understand supply-chain attacks where dependencies or build systems are compromised.",
        "masteryCriteria": [
          {
            "criteria": "Can explain supply-chain risks",
            "mastered": false
          },
          {
            "criteria": "Can audit dependencies",
            "mastered": false
          },
          {
            "criteria": "Can mitigate compromise impact",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Review dependency graphs",
            "completed": false
          },
          {
            "task": "Add integrity checks",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "supply-chain-attacks",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "SolarWinds Incident",
          "OWASP Dependency Risks"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Supply-Chain Attacks: When Trusted Code Betrays You",
          "gist": "Explain how dependency compromise happens.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T30-ST09",
        "title": "Dependency audits",
        "details": "Learn how to audit dependencies for vulnerabilities and risky maintenance patterns.",
        "masteryCriteria": [
          {
            "criteria": "Can run dependency audits",
            "mastered": false
          },
          {
            "criteria": "Can prioritize fixes",
            "mastered": false
          },
          {
            "criteria": "Can avoid false positives",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Audit dependencies",
            "completed": false
          },
          {
            "task": "Patch high-risk libraries",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "dependency-audits",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "npm audit",
          "Snyk Vulnerability Database"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Dependency Audits: Securing What You Don't Control",
          "gist": "Explain why third-party code is a major risk vector.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T30-ST10",
        "title": "Sandbox escapes (high-level)",
        "details": "Understand sandbox escapes conceptually and why isolation boundaries must not be blindly trusted.",
        "masteryCriteria": [
          {
            "criteria": "Can explain sandboxing",
            "mastered": false
          },
          {
            "criteria": "Can explain escape risks",
            "mastered": false
          },
          {
            "criteria": "Can design layered defenses",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Review sandbox assumptions",
            "completed": false
          },
          {
            "task": "Add defense-in-depth",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "sandbox-escapes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Browser Sandbox Architecture",
          "Container Escape Case Studies"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Sandbox Escapes: Why Isolation Is Never Absolute",
          "gist": "Explain why sandboxes reduce risk but don't eliminate it.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T31",
    "title": "Infrastructure as Code & Environment Parity",
    "parentTopic": "T17",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic focuses on making infrastructure reproducible, testable, and consistent across environments. Mastery means you can define infrastructure declaratively, prevent environment drift, manage secrets safely, and design for recovery when infrastructure inevitably fails.",
    "projectsCoveredIn": [
      "P5",
      "P6"
    ],
    "references": [
      "Terraform Documentation",
      "AWS CDK Concepts",
      "Google SRE Book - Disaster Recovery"
    ],
    "subTasks": [
      {
        "id": "T31-ST01",
        "title": "IaC basics (Terraform/CDK conceptually)",
        "details": "Understand Infrastructure as Code as defining infrastructure declaratively using tools like Terraform or CDK, without focusing on syntax mastery.",
        "masteryCriteria": [
          {
            "criteria": "Can explain IaC principles",
            "mastered": false
          },
          {
            "criteria": "Can compare Terraform and CDK conceptually",
            "mastered": false
          },
          {
            "criteria": "Can articulate benefits over manual provisioning",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Model infrastructure declaratively",
            "completed": false
          },
          {
            "task": "Review an existing IaC repo",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "iac-basics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Terraform Getting Started",
          "AWS CDK Overview"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Infrastructure as Code: Making Infrastructure Repeatable",
          "gist": "Explain why infrastructure should be treated like application code.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T31-ST02",
        "title": "Environment drift",
        "details": "Understand environment drift as the divergence between declared infrastructure and actual deployed state.",
        "masteryCriteria": [
          {
            "criteria": "Can explain environment drift",
            "mastered": false
          },
          {
            "criteria": "Can detect drift",
            "mastered": false
          },
          {
            "criteria": "Can prevent manual changes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Detect drift in environments",
            "completed": false
          },
          {
            "task": "Reconcile drift using IaC",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "environment-drift",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Terraform Drift Detection",
          "Environment Parity Concepts"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Environment Drift: Why Prod Is Never Like Staging",
          "gist": "Explain how drift occurs and how IaC prevents it.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T31-ST03",
        "title": "Config vs code separation",
        "details": "Understand the separation between configuration and code to enable environment-specific behavior without rebuilds.",
        "masteryCriteria": [
          {
            "criteria": "Can distinguish config from code",
            "mastered": false
          },
          {
            "criteria": "Can externalize configuration",
            "mastered": false
          },
          {
            "criteria": "Can avoid hard-coded values",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Externalize configuration",
            "completed": false
          },
          {
            "task": "Audit config usage",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "config-vs-code",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "12-Factor App - Config",
          "Runtime Configuration Patterns"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Config vs Code: Keeping Environments Flexible",
          "gist": "Explain why configuration must be separate from code.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T31-ST04",
        "title": "Secret management",
        "details": "Understand secure secret management practices for infrastructure and applications.",
        "masteryCriteria": [
          {
            "criteria": "Can manage secrets securely",
            "mastered": false
          },
          {
            "criteria": "Can avoid secrets in code",
            "mastered": false
          },
          {
            "criteria": "Can rotate secrets safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Integrate a secret manager",
            "completed": false
          },
          {
            "task": "Audit secret usage",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "secret-management",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS Secrets Manager",
          "HashiCorp Vault"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Secret Management: Keeping Credentials Out of Code",
          "gist": "Explain why secrets require specialized handling.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T31-ST05",
        "title": "Infrastructure testing",
        "details": "Understand testing strategies for infrastructure definitions to catch failures before deployment.",
        "masteryCriteria": [
          {
            "criteria": "Can test IaC changes",
            "mastered": false
          },
          {
            "criteria": "Can validate infrastructure plans",
            "mastered": false
          },
          {
            "criteria": "Can prevent destructive changes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add infrastructure tests",
            "completed": false
          },
          {
            "task": "Validate plans before apply",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "infrastructure-testing",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Terraform Plan and Apply",
          "Terratest Documentation"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Infrastructure Testing: Catching Failures Before They Ship",
          "gist": "Explain why infrastructure needs tests like application code.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T31-ST06",
        "title": "Multi-region basics",
        "details": "Understand deploying infrastructure across multiple regions for availability and resilience.",
        "masteryCriteria": [
          {
            "criteria": "Can explain multi-region benefits",
            "mastered": false
          },
          {
            "criteria": "Can identify complexity tradeoffs",
            "mastered": false
          },
          {
            "criteria": "Can avoid unnecessary duplication",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Design a multi-region setup",
            "completed": false
          },
          {
            "task": "Identify failover paths",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "multi-region-basics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS Multi-Region Architectures",
          "Google Cloud Multi-Region Design"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Multi-Region Basics: Availability at a Cost",
          "gist": "Explain when multi-region setups are worth the complexity.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T31-ST07",
        "title": "Disaster recovery planning",
        "details": "Understand disaster recovery planning as preparing systems to recover from catastrophic failures.",
        "masteryCriteria": [
          {
            "criteria": "Can define RTO and RPO",
            "mastered": false
          },
          {
            "criteria": "Can design recovery strategies",
            "mastered": false
          },
          {
            "criteria": "Can document DR plans",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create a DR plan",
            "completed": false
          },
          {
            "task": "Review recovery scenarios",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "disaster-recovery",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Disaster Recovery",
          "AWS Disaster Recovery Strategies"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Disaster Recovery Planning: Preparing for the Worst Day",
          "gist": "Explain how DR planning reduces downtime and data loss.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T31-ST08",
        "title": "Backup verification",
        "details": "Understand backup verification as regularly testing backups to ensure they can be restored successfully.",
        "masteryCriteria": [
          {
            "criteria": "Can verify backups",
            "mastered": false
          },
          {
            "criteria": "Can restore from backups",
            "mastered": false
          },
          {
            "criteria": "Can detect backup failures early",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Test backup restoration",
            "completed": false
          },
          {
            "task": "Automate backup checks",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "backup-verification",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Backup and Restore Best Practices",
          "AWS Backup Documentation"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Backup Verification: Backups That Actually Work",
          "gist": "Explain why untested backups are unreliable.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T32",
    "title": "Browser & Platform Edge Cases",
    "parentTopic": "T26",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic focuses on platform-specific behaviors that break otherwise correct applications. Mastery means you can design frontend systems that remain functional across browsers, devices, networks, locales, and accessibility modes.",
    "projectsCoveredIn": [
      "P2",
      "P4",
      "P6"
    ],
    "references": [
      "MDN Web Docs",
      "Web.dev - Progressive Web Apps",
      "Google Chrome Platform Status"
    ],
    "subTasks": [
      {
        "id": "T32-ST01",
        "title": "Cross-browser differences",
        "details": "Understand behavioral differences between browsers and how standards support, bugs, and polyfills affect applications.",
        "masteryCriteria": [
          {
            "criteria": "Can identify browser-specific issues",
            "mastered": false
          },
          {
            "criteria": "Can use feature detection",
            "mastered": false
          },
          {
            "criteria": "Can avoid browser sniffing",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Test features across browsers",
            "completed": false
          },
          {
            "task": "Add fallbacks for unsupported APIs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "cross-browser-differences",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "MDN Browser Compatibility Data",
          "Can I Use"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Cross-Browser Differences: Why Standards Aren't Enough",
          "gist": "Explain how browser differences surface despite shared standards.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T32-ST02",
        "title": "Mobile constraints",
        "details": "Understand mobile-specific constraints such as limited CPU, background tab suspension, and viewport behavior.",
        "masteryCriteria": [
          {
            "criteria": "Can explain mobile browser limits",
            "mastered": false
          },
          {
            "criteria": "Can design mobile-friendly interactions",
            "mastered": false
          },
          {
            "criteria": "Can avoid desktop assumptions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Profile mobile performance",
            "completed": false
          },
          {
            "task": "Test background/foreground behavior",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "mobile-constraints",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Web.dev - Mobile Performance",
          "Chrome Mobile Lifecycle"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Mobile Constraints: Designing for Limited Resources",
          "gist": "Explain how mobile environments differ fundamentally from desktop.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T32-ST03",
        "title": "Low-memory devices",
        "details": "Understand how low-memory devices behave and how aggressive memory reclamation affects apps.",
        "masteryCriteria": [
          {
            "criteria": "Can identify memory pressure signals",
            "mastered": false
          },
          {
            "criteria": "Can reduce memory usage",
            "mastered": false
          },
          {
            "criteria": "Can prevent crashes on low-end devices",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Test on low-memory simulators",
            "completed": false
          },
          {
            "task": "Reduce memory footprint",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "low-memory-devices",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Device Memory API",
          "Chrome Low-Memory Handling"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Low-Memory Devices: When the Browser Starts Killing Your App",
          "gist": "Explain how memory pressure changes application behavior.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T32-ST04",
        "title": "Offline-first patterns",
        "details": "Understand designing applications that function with intermittent or no connectivity.",
        "masteryCriteria": [
          {
            "criteria": "Can explain offline-first principles",
            "mastered": false
          },
          {
            "criteria": "Can use service workers",
            "mastered": false
          },
          {
            "criteria": "Can sync data safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build offline-capable features",
            "completed": false
          },
          {
            "task": "Test offline and sync flows",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "offline-first",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Service Workers Overview",
          "Offline-First Web Apps"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Offline-First Patterns: Designing for Broken Networks",
          "gist": "Explain why offline support improves reliability even online.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T32-ST05",
        "title": "Network flakiness",
        "details": "Understand how variable latency, packet loss, and disconnects affect frontend behavior.",
        "masteryCriteria": [
          {
            "criteria": "Can simulate flaky networks",
            "mastered": false
          },
          {
            "criteria": "Can design resilient request handling",
            "mastered": false
          },
          {
            "criteria": "Can avoid UI lockups",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Throttle network conditions",
            "completed": false
          },
          {
            "task": "Add retry and timeout handling",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "network-flakiness",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Chrome DevTools Network Throttling",
          "Resilient UI Patterns"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Network Flakiness: Designing for Unreliable Connectivity",
          "gist": "Explain how network instability breaks na\u00efve frontend logic.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T32-ST06",
        "title": "Accessibility edge cases",
        "details": "Understand accessibility edge cases involving screen readers, keyboard navigation, and assistive technologies.",
        "masteryCriteria": [
          {
            "criteria": "Can identify a11y edge cases",
            "mastered": false
          },
          {
            "criteria": "Can test with assistive tools",
            "mastered": false
          },
          {
            "criteria": "Can fix non-obvious issues",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Test with screen readers",
            "completed": false
          },
          {
            "task": "Fix keyboard navigation bugs",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "accessibility-edge-cases",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "WCAG Guidelines",
          "ARIA Authoring Practices"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Accessibility Edge Cases: Where Compliance Isn't Enough",
          "gist": "Explain how accessibility issues surface beyond basic checklists.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T32-ST07",
        "title": "Internationalization pitfalls",
        "details": "Understand pitfalls in internationalization such as text expansion, pluralization, and locale formatting.",
        "masteryCriteria": [
          {
            "criteria": "Can handle multiple locales",
            "mastered": false
          },
          {
            "criteria": "Can avoid hard-coded assumptions",
            "mastered": false
          },
          {
            "criteria": "Can test translated layouts",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add multi-language support",
            "completed": false
          },
          {
            "task": "Test layout expansion",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "i18n-pitfalls",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Intl API Documentation",
          "i18n Best Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Internationalization Pitfalls: When English Assumptions Break",
          "gist": "Explain how i18n issues surface in real products.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T32-ST08",
        "title": "Time zones & locale bugs",
        "details": "Understand how time zones and locale differences cause subtle and severe bugs.",
        "masteryCriteria": [
          {
            "criteria": "Can explain timezone pitfalls",
            "mastered": false
          },
          {
            "criteria": "Can store and display time safely",
            "mastered": false
          },
          {
            "criteria": "Can avoid locale-based logic errors",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Fix timezone-related bugs",
            "completed": false
          },
          {
            "task": "Test across time zones",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "timezone-locale-bugs",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Temporal Proposal",
          "Time Zone Handling Best Practices"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Time Zones & Locale Bugs: Why Time Is a Trap",
          "gist": "Explain why time handling is harder than it looks.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T33",
    "title": "Performance Pathologies (Advanced)",
    "parentTopic": "T12",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic focuses on common and catastrophic performance failure patterns seen in real systems. Mastery means you can recognize these pathologies quickly, explain their root causes, and apply the correct mitigations before scale turns slowness into outages.",
    "projectsCoveredIn": [
      "P2",
      "P5",
      "P6"
    ],
    "references": [
      "High Scalability Blog",
      "Designing Data-Intensive Applications - Martin Kleppmann",
      "Google SRE Book - Performance"
    ],
    "subTasks": [
      {
        "id": "T33-ST01",
        "title": "Thundering herd problems",
        "details": "Understand thundering herd scenarios where many clients or workers act simultaneously and overwhelm shared resources.",
        "masteryCriteria": [
          {
            "criteria": "Can explain thundering herd causes",
            "mastered": false
          },
          {
            "criteria": "Can identify herd amplification",
            "mastered": false
          },
          {
            "criteria": "Can design mitigation strategies",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Simulate herd scenarios",
            "completed": false
          },
          {
            "task": "Apply jitter or coordination",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "thundering-herd",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "AWS Thundering Herd Mitigation",
          "Distributed Locking Patterns"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Thundering Herd Problems: When Everyone Wakes Up at Once",
          "gist": "Explain how synchronized behavior collapses system performance.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T33-ST02",
        "title": "N+1 queries",
        "details": "Understand N+1 query problems where inefficient data access patterns explode query counts.",
        "masteryCriteria": [
          {
            "criteria": "Can identify N+1 patterns",
            "mastered": false
          },
          {
            "criteria": "Can refactor queries efficiently",
            "mastered": false
          },
          {
            "criteria": "Can measure query amplification",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Detect N+1 issues",
            "completed": false
          },
          {
            "task": "Apply batching or eager loading",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "n-plus-one",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "ORM Performance Pitfalls",
          "Database Query Optimization"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "N+1 Queries: The Silent Performance Killer",
          "gist": "Explain why small datasets hide N+1 problems until scale.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T33-ST03",
        "title": "Waterfall loading",
        "details": "Understand waterfall loading where sequential dependencies delay overall load times.",
        "masteryCriteria": [
          {
            "criteria": "Can identify waterfalls",
            "mastered": false
          },
          {
            "criteria": "Can parallelize work",
            "mastered": false
          },
          {
            "criteria": "Can eliminate unnecessary dependencies",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze network waterfalls",
            "completed": false
          },
          {
            "task": "Refactor loading order",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "waterfall-loading",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Chrome DevTools Waterfall Analysis",
          "Web Performance Optimization"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Waterfall Loading: Why Parallelism Matters",
          "gist": "Explain how serial dependencies slow applications.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T33-ST04",
        "title": "Hydration bottlenecks",
        "details": "Understand hydration bottlenecks in server-rendered applications where client-side work delays interactivity.",
        "masteryCriteria": [
          {
            "criteria": "Can explain hydration cost",
            "mastered": false
          },
          {
            "criteria": "Can identify hydration hotspots",
            "mastered": false
          },
          {
            "criteria": "Can reduce hydration scope",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Profile hydration time",
            "completed": false
          },
          {
            "task": "Apply partial or selective hydration",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "hydration-bottlenecks",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Next.js Hydration Performance",
          "Partial Hydration Techniques"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Hydration Bottlenecks: When SSR Isn't Enough",
          "gist": "Explain why hydration often becomes the new performance bottleneck.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T33-ST05",
        "title": "Over-fetching",
        "details": "Understand over-fetching where systems retrieve more data than necessary, wasting bandwidth and processing.",
        "masteryCriteria": [
          {
            "criteria": "Can identify over-fetching",
            "mastered": false
          },
          {
            "criteria": "Can tailor data responses",
            "mastered": false
          },
          {
            "criteria": "Can reduce payload sizes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Audit API responses",
            "completed": false
          },
          {
            "task": "Implement field selection",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "over-fetching",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "API Payload Optimization",
          "REST vs GraphQL Discussions"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Over-Fetching: Paying for Data You Don't Use",
          "gist": "Explain how excessive data transfer degrades performance.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T33-ST06",
        "title": "Excessive re-renders",
        "details": "Understand excessive re-renders in frontend frameworks and how state changes cascade into performance issues.",
        "masteryCriteria": [
          {
            "criteria": "Can detect unnecessary re-renders",
            "mastered": false
          },
          {
            "criteria": "Can optimize component updates",
            "mastered": false
          },
          {
            "criteria": "Can reduce render frequency",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Profile render behavior",
            "completed": false
          },
          {
            "task": "Optimize memoization",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "excessive-rerenders",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "React Profiler",
          "Frontend Performance Patterns"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Excessive Re-renders: When UI Updates Become the Bottleneck",
          "gist": "Explain how state misuse leads to rendering storms.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T33-ST07",
        "title": "Lock contention",
        "details": "Understand lock contention where competing threads or processes block each other, reducing throughput.",
        "masteryCriteria": [
          {
            "criteria": "Can explain lock contention",
            "mastered": false
          },
          {
            "criteria": "Can identify hot locks",
            "mastered": false
          },
          {
            "criteria": "Can reduce contention",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze contention points",
            "completed": false
          },
          {
            "task": "Refactor locking strategies",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "lock-contention",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Concurrency Control Concepts",
          "Database Locking Mechanisms"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Lock Contention: When Synchronization Kills Throughput",
          "gist": "Explain how contention limits scalability.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T33-ST08",
        "title": "Queue saturation",
        "details": "Understand queue saturation where backlog grows faster than it can be processed, leading to cascading delays.",
        "masteryCriteria": [
          {
            "criteria": "Can explain queue saturation",
            "mastered": false
          },
          {
            "criteria": "Can monitor queue depth",
            "mastered": false
          },
          {
            "criteria": "Can apply backpressure",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Simulate queue overload",
            "completed": false
          },
          {
            "task": "Apply rate limiting or scaling",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "queue-saturation",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Little's Law",
          "Backpressure in Distributed Systems"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Queue Saturation: When Backlogs Become Outages",
          "gist": "Explain how saturated queues degrade system performance.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T34",
    "title": "Developer Experience (DX) Engineering",
    "parentTopic": "T19",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic focuses on treating developer productivity as a first-class engineering concern. Mastery means you can design systems that reduce friction, standardize workflows, accelerate onboarding, and scale engineering output without burning people out.",
    "projectsCoveredIn": [
      "P2",
      "P6"
    ],
    "references": [
      "Accelerate - Forsgren, Humble, Kim",
      "Google Engineering Productivity Research",
      "ThoughtWorks Technology Radar - DX"
    ],
    "subTasks": [
      {
        "id": "T34-ST01",
        "title": "Fast local setup",
        "details": "Understand designing local development environments that are fast, reliable, and require minimal manual steps.",
        "masteryCriteria": [
          {
            "criteria": "Can reduce setup steps",
            "mastered": false
          },
          {
            "criteria": "Can automate environment bootstrapping",
            "mastered": false
          },
          {
            "criteria": "Can minimize time-to-first-commit",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Automate local setup",
            "completed": false
          },
          {
            "task": "Measure setup time",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "fast-local-setup",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Docker Compose Dev Environments",
          "Dev Containers"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Fast Local Setup: Reducing Time-to-First-Commit",
          "gist": "Explain why slow setup kills developer momentum.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T34-ST02",
        "title": "Consistent tooling",
        "details": "Understand enforcing consistent tooling versions and workflows across teams to reduce friction and bugs.",
        "masteryCriteria": [
          {
            "criteria": "Can standardize tooling",
            "mastered": false
          },
          {
            "criteria": "Can avoid tool version drift",
            "mastered": false
          },
          {
            "criteria": "Can reduce environment-specific bugs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Pin tool versions",
            "completed": false
          },
          {
            "task": "Automate tool checks",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "consistent-tooling",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "asdf / volta Tooling",
          "Monorepo Tooling Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Consistent Tooling: Eliminating \u2018Works on My Machine'",
          "gist": "Explain how tooling consistency improves reliability and speed.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T34-ST03",
        "title": "Monorepo vs multirepo tradeoffs",
        "details": "Understand the tradeoffs between monorepos and multirepos in terms of tooling, ownership, and scaling teams.",
        "masteryCriteria": [
          {
            "criteria": "Can compare repo strategies",
            "mastered": false
          },
          {
            "criteria": "Can evaluate team scale impact",
            "mastered": false
          },
          {
            "criteria": "Can avoid dogmatic decisions",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Analyze repo structure choices",
            "completed": false
          },
          {
            "task": "Document tradeoff decisions",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "mono-vs-multi",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google Monorepo Paper",
          "Nx / Turborepo Docs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Monorepo vs Multirepo: Choosing the Right Tradeoffs",
          "gist": "Explain why repo strategy depends on team and tooling maturity.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T34-ST04",
        "title": "Code generation",
        "details": "Understand using code generation to reduce repetitive work while avoiding unmaintainable abstractions.",
        "masteryCriteria": [
          {
            "criteria": "Can identify good generation targets",
            "mastered": false
          },
          {
            "criteria": "Can integrate generators safely",
            "mastered": false
          },
          {
            "criteria": "Can avoid codegen lock-in",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Generate boilerplate safely",
            "completed": false
          },
          {
            "task": "Review generated code lifecycle",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "code-generation",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "OpenAPI Codegen",
          "GraphQL Code Generator"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Code Generation: Automation Without Abstraction Debt",
          "gist": "Explain when code generation helps and when it hurts.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T34-ST05",
        "title": "Pre-commit hooks",
        "details": "Understand pre-commit hooks as a way to catch issues early without slowing developers down.",
        "masteryCriteria": [
          {
            "criteria": "Can design fast hooks",
            "mastered": false
          },
          {
            "criteria": "Can avoid blocking workflows",
            "mastered": false
          },
          {
            "criteria": "Can enforce quality locally",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add pre-commit hooks",
            "completed": false
          },
          {
            "task": "Measure hook execution time",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "pre-commit-hooks",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Husky",
          "Lint-Staged"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Pre-Commit Hooks: Catching Bugs Before They Leave Your Laptop",
          "gist": "Explain how early feedback improves code quality.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T34-ST06",
        "title": "Lint rule design",
        "details": "Understand designing lint rules that enforce standards without creating noise or resentment.",
        "masteryCriteria": [
          {
            "criteria": "Can design meaningful rules",
            "mastered": false
          },
          {
            "criteria": "Can avoid over-restrictive linting",
            "mastered": false
          },
          {
            "criteria": "Can evolve rules over time",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write custom lint rules",
            "completed": false
          },
          {
            "task": "Tune rule severity",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "lint-rule-design",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "ESLint Rule Authoring",
          "Effective Linting Practices"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Lint Rule Design: Enforcing Standards Without Slowing Teams",
          "gist": "Explain why bad lint rules harm DX.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T34-ST07",
        "title": "Internal CLI tools",
        "details": "Understand building internal CLI tools to automate repetitive workflows and enforce standards.",
        "masteryCriteria": [
          {
            "criteria": "Can identify automation opportunities",
            "mastered": false
          },
          {
            "criteria": "Can build ergonomic CLIs",
            "mastered": false
          },
          {
            "criteria": "Can maintain internal tools",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build an internal CLI",
            "completed": false
          },
          {
            "task": "Automate common workflows",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "internal-cli-tools",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Node.js CLI Best Practices",
          "Developer Tooling Case Studies"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Internal CLI Tools: Scaling Engineering Through Automation",
          "gist": "Explain how small tools unlock large productivity gains.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T34-ST08",
        "title": "Docs as code",
        "details": "Understand managing documentation like code, with versioning, reviews, and automated publishing.",
        "masteryCriteria": [
          {
            "criteria": "Can version documentation",
            "mastered": false
          },
          {
            "criteria": "Can integrate docs with CI",
            "mastered": false
          },
          {
            "criteria": "Can keep docs in sync with code",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Move docs into repo",
            "completed": false
          },
          {
            "task": "Automate docs publishing",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "docs-as-code",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Docs-as-Code Philosophy",
          "MkDocs / Docusaurus"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Docs as Code: Keeping Knowledge Alive and Accurate",
          "gist": "Explain why documentation needs the same rigor as code.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T35",
    "title": "Migration & Legacy System Strategy",
    "parentTopic": "T18",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic focuses on evolving real-world systems that already exist. Mastery means you can migrate incrementally, maintain feature parity, control risk, and modernize systems without breaking users or halting development.",
    "projectsCoveredIn": [
      "P5",
      "P6"
    ],
    "references": [
      "Refactoring - Martin Fowler",
      "Building Evolutionary Architectures",
      "AWS Builders Library - Migrations"
    ],
    "subTasks": [
      {
        "id": "T35-ST01",
        "title": "Incremental refactors",
        "details": "Understand refactoring large systems incrementally instead of through risky big-bang rewrites.",
        "masteryCriteria": [
          {
            "criteria": "Can plan incremental refactors",
            "mastered": false
          },
          {
            "criteria": "Can maintain system stability",
            "mastered": false
          },
          {
            "criteria": "Can measure progress safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Refactor a subsystem incrementally",
            "completed": false
          },
          {
            "task": "Add safety tests before refactors",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "incremental-refactors",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Martin Fowler - Refactoring",
          "Legacy Code Change Patterns"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Incremental Refactors: Changing Systems Without Breaking Them",
          "gist": "Explain why gradual refactoring beats rewrites.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T35-ST02",
        "title": "Strangler fig pattern",
        "details": "Understand the strangler fig pattern for replacing legacy systems piece by piece.",
        "masteryCriteria": [
          {
            "criteria": "Can explain strangler fig pattern",
            "mastered": false
          },
          {
            "criteria": "Can route traffic incrementally",
            "mastered": false
          },
          {
            "criteria": "Can retire legacy components safely",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Design a strangler migration",
            "completed": false
          },
          {
            "task": "Route traffic between old and new systems",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "strangler-fig",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Martin Fowler - Strangler Fig",
          "Migration Architecture Patterns"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "The Strangler Fig Pattern: Replacing Systems Without a Rewrite",
          "gist": "Explain how to gradually replace legacy systems.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T35-ST03",
        "title": "Schema migration safety",
        "details": "Understand safe database schema evolution while supporting old and new application versions.",
        "masteryCriteria": [
          {
            "criteria": "Can design backward-compatible schemas",
            "mastered": false
          },
          {
            "criteria": "Can avoid breaking live traffic",
            "mastered": false
          },
          {
            "criteria": "Can coordinate multi-version apps",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Perform safe schema migrations",
            "completed": false
          },
          {
            "task": "Test migrations under load",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "schema-migration-safety",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Zero-Downtime Migration Patterns",
          "Database Migration Best Practices"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Schema Migration Safety: Evolving Databases Without Downtime",
          "gist": "Explain how to migrate schemas while apps are live.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T35-ST04",
        "title": "Feature parity strategies",
        "details": "Understand how to maintain feature parity between old and new systems during migration.",
        "masteryCriteria": [
          {
            "criteria": "Can track feature parity",
            "mastered": false
          },
          {
            "criteria": "Can avoid regressions",
            "mastered": false
          },
          {
            "criteria": "Can decide when parity is sufficient",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create parity checklists",
            "completed": false
          },
          {
            "task": "Validate behavior across systems",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "feature-parity",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "System Migration Case Studies",
          "Backward Compatibility Testing"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Feature Parity Strategies: Migrating Without Regressions",
          "gist": "Explain how to ensure new systems fully replace old ones.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T35-ST05",
        "title": "Dual writes",
        "details": "Understand dual-write strategies and their risks when migrating data stores or services.",
        "masteryCriteria": [
          {
            "criteria": "Can explain dual-write risks",
            "mastered": false
          },
          {
            "criteria": "Can ensure consistency",
            "mastered": false
          },
          {
            "criteria": "Can plan exit strategies",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Implement controlled dual writes",
            "completed": false
          },
          {
            "task": "Monitor data divergence",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "dual-writes",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Distributed Data Migration Patterns",
          "Consistency Guarantees"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Dual Writes: Necessary Evil or Hidden Time Bomb?",
          "gist": "Explain when dual writes are unavoidable and how to manage them.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T35-ST06",
        "title": "Kill switches",
        "details": "Understand kill switches as fast mechanisms to disable new functionality during failures.",
        "masteryCriteria": [
          {
            "criteria": "Can design kill switches",
            "mastered": false
          },
          {
            "criteria": "Can trigger switches safely",
            "mastered": false
          },
          {
            "criteria": "Can limit blast radius",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add kill switches to features",
            "completed": false
          },
          {
            "task": "Test emergency disable flows",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "kill-switches",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Feature Flag Kill Switch Patterns",
          "Operational Safety Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Kill Switches: Turning Off Features to Save Systems",
          "gist": "Explain why kill switches are essential during migrations.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T35-ST07",
        "title": "Risk management",
        "details": "Understand identifying, assessing, and mitigating risks during system migrations.",
        "masteryCriteria": [
          {
            "criteria": "Can identify migration risks",
            "mastered": false
          },
          {
            "criteria": "Can prioritize mitigations",
            "mastered": false
          },
          {
            "criteria": "Can communicate risk clearly",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Create migration risk registers",
            "completed": false
          },
          {
            "task": "Run risk review sessions",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "migration-risk-management",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Migration Risk Assessment Frameworks",
          "Change Management Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Risk Management in Migrations: Planning for What Can Go Wrong",
          "gist": "Explain how proactive risk management prevents disasters.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  },
  {
    "id": "T36",
    "title": "Debugging Philosophy (Meta-Skill)",
    "parentTopic": "T13",
    "priority": "high",
    "difficulty": "hard",
    "details": "This topic focuses on debugging as a disciplined engineering practice rather than ad-hoc trial and error. Mastery means you can form strong hypotheses, reduce problem space systematically, debug production safely, and extract durable learnings after incidents.",
    "projectsCoveredIn": [
      "P2",
      "P5",
      "P6"
    ],
    "references": [
      "Debugging - David J. Agans",
      "Google SRE Book - Incident Response",
      "Charity Majors - Debugging Production Systems"
    ],
    "subTasks": [
      {
        "id": "T36-ST01",
        "title": "Hypothesis-driven debugging",
        "details": "Understand debugging as forming testable hypotheses and validating them with evidence instead of random changes.",
        "masteryCriteria": [
          {
            "criteria": "Can articulate clear hypotheses",
            "mastered": false
          },
          {
            "criteria": "Can design tests to validate hypotheses",
            "mastered": false
          },
          {
            "criteria": "Can avoid speculative fixes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Write hypotheses before debugging",
            "completed": false
          },
          {
            "task": "Validate hypotheses with data",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "hypothesis-driven-debugging",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Debugging - David J. Agans",
          "Scientific Method in Engineering"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Hypothesis-Driven Debugging: Stop Guessing, Start Testing",
          "gist": "Explain why disciplined hypotheses outperform trial-and-error debugging.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T36-ST02",
        "title": "Binary search debugging",
        "details": "Understand binary search debugging as systematically halving the problem space to isolate failures quickly.",
        "masteryCriteria": [
          {
            "criteria": "Can apply divide-and-conquer debugging",
            "mastered": false
          },
          {
            "criteria": "Can choose meaningful checkpoints",
            "mastered": false
          },
          {
            "criteria": "Can reduce large systems quickly",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Bisect failures across layers",
            "completed": false
          },
          {
            "task": "Apply binary search to regressions",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "binary-search-debugging",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Git Bisect Documentation",
          "Debugging Large Systems"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Binary Search Debugging: Finding Bugs Faster by Halving the Problem",
          "gist": "Explain how divide-and-conquer accelerates debugging in complex systems.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T36-ST03",
        "title": "Production debugging safely",
        "details": "Understand how to debug issues in production without causing additional outages or data corruption.",
        "masteryCriteria": [
          {
            "criteria": "Can debug without mutating state",
            "mastered": false
          },
          {
            "criteria": "Can minimize blast radius",
            "mastered": false
          },
          {
            "criteria": "Can use read-only inspection",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Perform read-only production debugging",
            "completed": false
          },
          {
            "task": "Use shadow or canary inspection",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "production-debugging",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Google SRE - Production Debugging",
          "Observability-First Debugging"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Production Debugging Safely: First, Do No Harm",
          "gist": "Explain safe techniques for investigating live systems.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T36-ST04",
        "title": "Reproduction strategies",
        "details": "Understand techniques for reproducing bugs locally or in controlled environments.",
        "masteryCriteria": [
          {
            "criteria": "Can create minimal reproductions",
            "mastered": false
          },
          {
            "criteria": "Can isolate triggering conditions",
            "mastered": false
          },
          {
            "criteria": "Can reproduce nondeterministic bugs",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Build minimal repro cases",
            "completed": false
          },
          {
            "task": "Reproduce race conditions",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "repo",
            "label": "reproduction-strategies",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Minimal Reproducible Examples",
          "Debugging Non-Deterministic Bugs"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Reproduction Strategies: Making Bugs Repeatable",
          "gist": "Explain why reproducibility is the fastest path to fixes.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T36-ST05",
        "title": "Instrument-before-guessing",
        "details": "Understand adding instrumentation before drawing conclusions to reveal real system behavior.",
        "masteryCriteria": [
          {
            "criteria": "Can identify missing signals",
            "mastered": false
          },
          {
            "criteria": "Can add targeted instrumentation",
            "mastered": false
          },
          {
            "criteria": "Can avoid assumption-based debugging",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Add temporary instrumentation",
            "completed": false
          },
          {
            "task": "Validate assumptions with data",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "notes",
            "label": "instrument-before-guessing",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Observability Engineering",
          "Production Debugging Best Practices"
        ],
        "estimatedHours": 2,
        "status": "not-started",
        "blog": {
          "title": "Instrument Before Guessing: Let the System Tell You the Truth",
          "gist": "Explain why data beats intuition during incidents.",
          "published": false,
          "url": ""
        }
      },
      {
        "id": "T36-ST06",
        "title": "Post-incident forensics",
        "details": "Understand post-incident forensics as reconstructing events after failures to identify systemic causes.",
        "masteryCriteria": [
          {
            "criteria": "Can reconstruct incident timelines",
            "mastered": false
          },
          {
            "criteria": "Can correlate logs, metrics, and traces",
            "mastered": false
          },
          {
            "criteria": "Can identify systemic\u2014not individual\u2014causes",
            "mastered": false
          }
        ],
        "practiceTasks": [
          {
            "task": "Perform post-incident analysis",
            "completed": false
          },
          {
            "task": "Document forensic timelines",
            "completed": false
          }
        ],
        "artifacts": [
          {
            "type": "doc",
            "label": "post-incident-forensics",
            "url": "",
            "status": "not-started"
          }
        ],
        "references": [
          "Blameless Postmortems",
          "Incident Analysis Frameworks"
        ],
        "estimatedHours": 3,
        "status": "not-started",
        "blog": {
          "title": "Post-Incident Forensics: Understanding Failures After the Fire",
          "gist": "Explain how forensic analysis turns incidents into long-term improvements.",
          "published": false,
          "url": ""
        }
      }
    ],
    "tracking": {
      "confidence": 0,
      "lastReviewed": null,
      "notes": ""
    },
    "status": "not-started"
  }
]